{"version":3,"file":"static/js/838.75dee7d7.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/scene/text/canvas/BatchableText.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextGenerator.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/filters/defaults/passthrough/PassthroughFilter.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/init.ts","../node_modules/pixi.js/src/scene/text-html/BatchableHTMLText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts"],"sourcesContent":["import { BatchableSprite } from '../../sprite/BatchableSprite';\n\n/** @internal */\nexport class BatchableText extends BatchableSprite\n{\n    public currentKey: string;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { updateTextBounds } from '../utils/updateTextBounds';\nimport { BatchableText } from './BatchableText';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _managedTexts: GCManagedHash<Text>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.runners.resolutionChange.add(this);\n        this._managedTexts = new GCManagedHash({\n            renderer,\n            type: 'renderable',\n            onUnload: this.onTextUnload.bind(this),\n            name: 'canvasText'\n        });\n    }\n\n    protected resolutionChange()\n    {\n        for (const key in this._managedTexts.items)\n        {\n            const text = this._managedTexts.items[key];\n\n            if (text?._autoResolution) text.onViewUpdate();\n        }\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text.styleKey;\n\n        if (gpuText.currentKey !== newKey) return true;\n\n        return text._didTextUpdate;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (text._didTextUpdate)\n        {\n            const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n            if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(text);\n            }\n\n            text._didTextUpdate = false;\n\n            updateTextBounds(batchableText, text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        batchableText._batcher.updateElement(batchableText);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (batchableText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);\n        }\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n        batchableText.texture = this._renderer.canvasText.getManagedTexture(text);\n        batchableText.currentKey = text.styleKey;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const batchableText = new BatchableText();\n\n        batchableText.currentKey = '--';\n        batchableText.renderable = text;\n        batchableText.transform = text.groupTransform;\n        batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableText.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        text._gpuData[this._renderer.uid] = batchableText;\n        this._managedTexts.add(text);\n\n        return batchableText;\n    }\n\n    protected onTextUnload(text: Text)\n    {\n        const gpuData = text._gpuData[this._renderer.uid];\n\n        if (!gpuData) return;\n\n        const { canvasText } = this._renderer;\n        const refCount = canvasText.getReferenceCount(gpuData.currentKey);\n\n        if (refCount > 0)\n        {\n            canvasText.decreaseReferenceCount(gpuData.currentKey);\n        }\n        else if (gpuData.texture)\n        {\n            canvasText.returnTexture(gpuData.texture);\n        }\n    }\n\n    public destroy()\n    {\n        this._managedTexts.destroy();\n        this._renderer = null;\n    }\n}\n","import { DOMAdapter } from '../../environment/adapter';\nimport { nextPow2 } from '../../maths/misc/pow2';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\n\n// Internal canvas for measuring bounds\nlet _internalCanvas: ICanvas | null = null;\nlet _internalContext: ICanvasRenderingContext2D | null = null;\n\nfunction ensureInternalCanvas(width: number, height: number): void\n{\n    if (!_internalCanvas)\n    {\n        _internalCanvas = DOMAdapter.get().createCanvas(256, 128);\n        _internalContext = _internalCanvas.getContext('2d', { willReadFrequently: true });\n        _internalContext.globalCompositeOperation = 'copy';\n        _internalContext.globalAlpha = 1;\n    }\n\n    if (_internalCanvas.width < width || _internalCanvas.height < height)\n    {\n        // Use power-of-two dimensions for better performance\n        _internalCanvas.width = nextPow2(width);\n        _internalCanvas.height = nextPow2(height);\n    }\n}\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/** @internal */\nexport interface GetCanvasBoundingBoxOptions\n{\n    /** The canvas to measure */\n    canvas: ICanvas;\n    /** Optional. The width to analyze (defaults to canvas.width) */\n    width?: number;\n    /** Optional. The height to analyze (defaults to canvas.height) */\n    height?: number;\n    /**\n     * Optional. The resolution at which to analyze the canvas, between 0-1.\n     * Lower values improve performance for large canvases but may be less precise.\n     * Default is 1 (full resolution).\n     */\n    resolution?: number;\n    /** Optional. The rectangle to store the result in. */\n    output?: Rectangle;\n}\n\n/**\n * Measures the bounding box of a canvas's visible (non-transparent) pixels.\n *\n * This function analyzes the alpha channel of the canvas pixels to find the smallest\n * rectangle containing all non-transparent pixels. It's useful for optimizing sprite\n * rendering by trimming transparent borders.\n *\n * Uses an internal canvas with `willReadFrequently: true` for efficient pixel data access.\n * This internal canvas is reused between calls for better performance.\n * @example\n * ```typescript\n * // Basic usage - get trim bounds at full resolution\n * const bounds = getCanvasBoundingBox({ canvas: myCanvas });\n * console.log(bounds); // Rectangle{x: 10, y: 5, width: 100, height: 200}\n * // Optimized for performance with lower resolution scanning\n * const fastBounds = getCanvasBoundingBox({\n *     canvas: largeCanvas,\n *     width: largeCanvas.width,\n *     height: largeCanvas.height,\n *     resolution: 0.5\n * });\n * // Resolution of 0.5 means scanning at half size, much faster for large canvases\n *\n * // Using custom dimensions - only analyze part of the canvas\n * const partialBounds = getCanvasBoundingBox({ canvas: myCanvas, width: 100, height: 100 });\n * // Only analyzes a 100x100 region starting from top-left\n * ```\n * @param options - The options for measuring the bounding box, including the canvas to measure.\n * @returns The bounding box as a Rectangle containing the visible content.\n *          Returns Rectangle.EMPTY if the canvas is completely transparent.\n * @internal\n */\nexport function getCanvasBoundingBox(\n    options: GetCanvasBoundingBoxOptions,\n): Rectangle;\n/**\n * @param canvas\n * @param resolution\n * @internal\n * @deprecated since 8.10.0\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution?: number): Rectangle;\n/**\n * @param {...any} args\n * @internal\n */\nexport function getCanvasBoundingBox(...args: [GetCanvasBoundingBoxOptions] | [ICanvas, number?]): Rectangle\n{\n    let options = args[0] as GetCanvasBoundingBoxOptions;\n\n    if (!options.canvas)\n    {\n        options = { canvas: args[0] as ICanvas, resolution: args[1] };\n    }\n\n    const { canvas } = options; // canvas is correctly extracted from options\n\n    // Cap resolution at 1\n    const resolution = Math.min(options.resolution ?? 1, 1);\n    const width = options.width ?? canvas.width;\n    const height = options.height ?? canvas.height;\n    let output = options.output;\n\n    // Ensure internal canvas is large enough\n    ensureInternalCanvas(width, height);\n\n    if (!_internalContext)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    // Set up for pixel replacement (no blending)\n    _internalContext.drawImage(\n        canvas as unknown as CanvasImageSource,\n        0, 0,\n        width, height,\n        0, 0,\n        width * resolution, height * resolution\n    );\n\n    // Get the image data at full resolution\n    const imageData = _internalContext.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    _internalContext.globalCompositeOperation = 'source-over';\n    // draw the rect on the canvas\n    _internalContext.strokeRect(left, top, right - left, bottom - top);\n    _internalContext.globalCompositeOperation = 'copy';\n\n    output ??= new Rectangle();\n\n    output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n\n    return output;\n}\n\n","import { Color } from '../../../color/Color';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\nimport { type CanvasAndContext, CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { type TextStyle } from '../TextStyle';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\n/**\n * Temporary rectangle for getting the bounding box of the text.\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Utility for generating and managing canvas-based text rendering.\n *\n * This class is responsible for rendering text to canvas elements based on provided styles,\n * measuring the resulting text dimensions, and managing the lifecycle of canvas resources.\n *\n * CanvasTextGenerator supports:\n * - Text rendering with various styles (fill, stroke, gradient, etc.)\n * - Drop shadows and letter spacing\n * - Automatic trimming of transparent pixels\n * - Canvas resource pooling\n *\n * As a singleton, it's accessed via the exported `CanvasTextGenerator` constant.\n * @example\n * ```typescript\n * // Basic usage - render text to a canvas\n * import { CanvasTextGenerator } from 'pixi.js';\n * import { TextStyle } from 'pixi.js';\n *\n * // Create a text style\n * const style = new TextStyle({\n *   fontFamily: 'Arial',\n *   fontSize: 24,\n *   fill: 0xff1010,\n *   align: 'center',\n * });\n *\n * // Get a canvas with the text rendered to it\n * const { canvasAndContext, frame } = CanvasTextGenerator.getCanvasAndContext({\n *   text: 'Hello Pixi!',\n *   style,\n *   resolution: 1\n * });\n *\n * @internal\n */\nclass CanvasTextGeneratorClass\n{\n    /**\n     * Creates a canvas with the specified text rendered to it.\n     *\n     * Generates a canvas of appropriate size, renders the text with the provided style,\n     * and returns both the canvas/context and a Rectangle representing the text bounds.\n     *\n     * When trim is enabled in the style, the frame will represent the bounds of the\n     * non-transparent pixels, which can be smaller than the full canvas.\n     * @param options - The options for generating the text canvas\n     * @param options.text - The text to render\n     * @param options.style - The style to apply to the text\n     * @param options.resolution - The resolution of the canvas (defaults to 1)\n     * @param options.padding\n     * @returns An object containing the canvas/context and the frame (bounds) of the text\n     */\n    public getCanvasAndContext(options: {text: string, style: TextStyle, resolution?: number, padding?: number})\n    {\n        const { text, style, resolution = 1 } = options;\n\n        const padding = (style as TextStyle)._getFinalPadding();\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);\n\n        const frame = style.trim\n            ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect })\n            : tempRect.set(0, 0, width, height);\n\n        return {\n            canvasAndContext,\n            frame\n        };\n    }\n\n    /**\n     * Returns a canvas and context to the pool.\n     *\n     * This should be called when you're done with the canvas to allow reuse\n     * and prevent memory leaks.\n     * @param canvasAndContext - The canvas and context to return to the pool\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @param text - The text to render\n     * @param style - The style of the text\n     * @param padding - The padding of the text\n     * @param resolution - The resolution of the text\n     * @param canvasAndContext - The canvas and context to render the text to\n     */\n    private _renderTextToCanvas(\n        text: string,\n        style: TextStyle,\n        padding: number,\n        resolution: number,\n        canvasAndContext: CanvasAndContext\n    ): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured, padding * 2) : null;\n\n                if (style._stroke?.width)\n                {\n                    const strokePadding = (style._stroke.width * 0.5) + (padding * 2);\n\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, strokePadding);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     *\n     * This method handles rendering text with the correct letter spacing, using either:\n     * 1. Native letter spacing if supported by the browser\n     * 2. Manual letter spacing calculation if not natively supported\n     *\n     * For manual letter spacing, it calculates the position of each character\n     * based on its width and the desired spacing.\n     * @param text - The text to draw\n     * @param style - The text style to apply\n     * @param canvasAndContext - The canvas and context to draw to\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Whether to render the stroke (true) or fill (false)\n     * @private\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n}\n\n/** @internal */\nexport const CanvasTextGenerator = new CanvasTextGeneratorClass();\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Filter } from '../../../filters/Filter';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { type CanvasTextOptions, type Text } from '../Text';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextGenerator } from './CanvasTextGenerator';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    public getTexture(options: CanvasTextOptions): Texture;\n    public getTexture(\n        options: CanvasTextOptions | string,\n        _resolution?: number,\n        _style?: TextStyle,\n        _textKey?: string\n    ): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        if (!(options.textureStyle instanceof TextureStyle))\n        {\n            options.textureStyle = new TextureStyle(options.textureStyle);\n        }\n\n        if (typeof options.text !== 'string')\n        {\n            options.text = options.text.toString();\n        }\n\n        const { text, style, textureStyle } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n            text: text as string,\n            style: style as TextStyle,\n            resolution,\n        });\n\n        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n\n        if (textureStyle) texture.source.style = textureStyle as TextureStyle;\n\n        if (style.trim)\n        {\n            // reapply the padding to the frame\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n\n            // We initially increased the frame size by a resolution factor\n            // to achieve a crisper display. Now we need to scale down the already\n            // trimmed frame to render the texture in the expected size.\n            texture.frame.scale(1 / resolution);\n            texture.updateUvs();\n        }\n\n        if (style.filters)\n        {\n            // apply the filters to the texture if required..\n            // this returns a new texture with the filters applied\n            const filteredTexture = this._applyFilters(texture, style.filters as Filter[]);\n\n            // return the original texture to the pool so we can reuse the next frame\n            this.returnTexture(texture);\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            // return the new texture with the filters applied\n            return filteredTexture;\n        }\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture, true);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @deprecated since 8.10.0\n     */\n    public renderTextToCanvas(): void\n    {\n        // #if _DEBUG\n        deprecation(\n            '8.10.0',\n            'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead'\n        );\n        // #endif\n    }\n\n    /**\n     * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n     * @param text - The Text object that needs a texture\n     * @returns A Texture instance that represents the rendered text\n     * @remarks\n     * This method performs the following:\n     * 1. Sets the appropriate resolution based on auto-resolution settings\n     * 2. Checks if a texture already exists for the text's style\n     * 3. Creates a new texture if needed or returns an existing one\n     * 4. Manages reference counting for texture reuse\n     */\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const texture = this.getTexture({\n            text: text.text,\n            style: text.style,\n            resolution: text._resolution,\n            textureStyle: text.textureStyle,\n        });\n\n        this._activeTextures[textKey] = {\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    /**\n     * Decreases the reference count for a texture associated with a text key.\n     * When the reference count reaches zero, the texture is returned to the pool.\n     * @param textKey - The unique key identifying the text style configuration\n     * @remarks\n     * This method is crucial for memory management, ensuring textures are properly\n     * cleaned up when they are no longer needed by any Text instances.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            this.returnTexture(activeTexture.texture);\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? 0;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Applies the specified filters to the given texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n     * texture is set to 'premultiplied-alpha'.\n     * @param {Texture} texture - The texture to which the filters will be applied.\n     * @param {Filter[]} filters - The filters to apply to the texture.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     */\n    private _applyFilters(texture: Texture, filters: Filter[]): Texture\n    {\n        // Save the current render target so it can be restored later\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n\n        // Apply the filters to the texture and get the resulting texture\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture,\n            filters,\n        });\n\n        // Set the alpha mode of the resulting texture to 'premultiplied-alpha'\n\n        // Restore the previous render target\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n\n        // Return the resulting texture with the filters applied\n        return resultTexture;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        // Clean up active textures\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexture(this._activeTextures[key].texture);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","/** @internal */\nexport const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\n/** @internal */\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/**\n * The shader used by the TilingSprite.\n * @internal\n */\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\n/** @internal */\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { type GPUData } from '../view/ViewContainer';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\nconst sharedQuad = new QuadGeometry();\n\n/** @internal */\nexport class TilingSpriteGpuData implements GPUData\n{\n    public canBatch: boolean = true;\n    public renderable: TilingSprite;\n    public batchableMesh?: BatchableMesh;\n    public geometry?: MeshGeometry;\n    public shader?: TilingSpriteShader;\n\n    constructor()\n    {\n        this.geometry = new MeshGeometry({\n            indices: sharedQuad.indices.slice(),\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n        this.shader?.destroy();\n    }\n}\n\n/**\n * The TilingSpritePipe is a render pipe for rendering TilingSprites.\n * It handles the batching and rendering of TilingSprites using a shader.\n * @internal\n */\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n    private readonly _managedTilingSprites: GCManagedHash<TilingSprite>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedTilingSprites = new GCManagedHash({ renderer, type: 'renderable', name: 'tilingSprite' });\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._getTilingSpriteData(tilingSprite);\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): TilingSpriteGpuData\n    {\n        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): TilingSpriteGpuData\n    {\n        const gpuData = new TilingSpriteGpuData();\n\n        gpuData.renderable = tilingSprite;\n        tilingSprite._gpuData[this._renderer.uid] = gpuData;\n\n        this._managedTilingSprites.add(tilingSprite);\n\n        return gpuData;\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        this._managedTilingSprites.destroy();\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param uvs\n * @internal\n */\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * @param array\n * @param stride\n * @param offset\n * @param matrix\n * @internal\n */\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param positions\n * @internal\n */\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import { type GPUData } from '../view/ViewContainer';\n\nimport type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement, GPUData\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        this.reset();\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { type Renderer } from '../../../rendering/renderers/types';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext } from './GraphicsContextSystem';\n\n/** @internal */\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    contextChange(renderer: Renderer): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\n\n/** @internal */\nexport class GraphicsGpuData implements GPUData\n{\n    public batches: BatchableGraphics[] = [];\n    public batched = false;\n    public destroy()\n    {\n        this.batches.forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this.batches.length = 0;\n    }\n}\n\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n\n    private _adaptor: GraphicsAdaptor;\n    private readonly _managedGraphics: GCManagedHash<Graphics>;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n        this.renderer.runners.contextChange.add(this);\n        this._managedGraphics = new GCManagedHash({ renderer, type: 'renderable', priority: -1, name: 'graphics' });\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n        const context = graphics.context;\n\n        const wasBatched = !!graphics._gpuData;\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const batches = gpuData.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batch._batcher.updateElement(batch);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // free up the batches..\n        gpuData.destroy();\n\n        if (gpuContext.isBatchable)\n        {\n            this._updateBatchesForRenderable(graphics, gpuData);\n        }\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n\n    private _initGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        const gpuData = new GraphicsGpuData();\n\n        graphics._gpuData[this.renderer.uid] = gpuData;\n\n        this._managedGraphics.add(graphics);\n\n        return gpuData;\n    }\n\n    private _updateBatchesForRenderable(graphics: Graphics, gpuData: GraphicsGpuData)\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        gpuData.batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n    }\n\n    public destroy()\n    {\n        this._managedGraphics.destroy();\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\n/** @internal */\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */`\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\n/** @internal */\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */`\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","/** @internal */\nexport const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `,\n    }\n\n};\n\n/** @internal */\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/** @internal */\nexport class SdfShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { type GPUData } from '../view/ViewContainer';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { BitmapText } from './BitmapText';\n\n/** @internal */\nexport class BitmapTextGraphics extends Graphics implements GPUData\n{\n    public destroy()\n    {\n        if (this.context.customShader)\n        {\n            this.context.customShader.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\n/** @internal */\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _managedBitmapTexts: GCManagedHash<BitmapText>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedBitmapTexts = new GCManagedHash({ renderer, type: 'renderable', priority: -2, name: 'bitmapText' });\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                // TODO: Check if this is a WebGL renderer before asserting type\n                context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n            }\n        }\n\n        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        let fontSize = bitmapFont.fontMetrics.fontSize;\n        let lineHeight = bitmapFont.lineHeight;\n\n        if (style.lineHeight)\n        {\n            fontSize = style.fontSize / scale;\n            lineHeight = style.lineHeight / scale;\n        }\n\n        let linePositionYShift = (lineHeight - fontSize) / 2;\n\n        // if `currentY` is no longer starts from `baseLineOffset`\n        // the `baseLineOffset` below may also need to be removed\n        if (linePositionYShift - bitmapFont.baseLineOffset < 0)\n        {\n            linePositionYShift = 0;\n        }\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = line.chars[j];\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    const texture = charData.texture;\n\n                    context.texture(\n                        texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset + linePositionYShift),\n                        texture.orig.width,\n                        texture.orig.height,\n                    );\n                }\n            }\n\n            currentY += lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = new BitmapTextGraphics();\n\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        this._managedBitmapTexts.add(bitmapText);\n\n        return proxyRenderable;\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        this._managedBitmapTexts.destroy();\n        this._renderer = null;\n        (this._managedBitmapTexts as null) = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Filter } from '../../Filter';\nimport vertex from '../defaultFilter.vert';\nimport fragment from './passthrough.frag';\nimport source from './passthrough.wgsl';\n\n/**\n * The PassthroughFilter passes the input data through without altering it.\n * It serves as a basic filter, performing no graphical alterations.\n * @category filters\n * @internal\n */\nexport class PassthroughFilter extends Filter\n{\n    constructor()\n    {\n        const gpuProgram = GpuProgram.from({\n            vertex: { source, entryPoint: 'mainVertex' },\n            fragment: { source, entryPoint: 'mainFragment' },\n            name: 'passthrough-filter'\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'passthrough-filter'\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n        });\n    }\n}\n","import { Matrix } from '../../../maths';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\n/**\n * This matrix is used for calculations of the bounds for renderables placed inside cacheAsTexture render groups.\n * @ignore\n * @internal\n */\nconst tempProjectionMatrix: Matrix = new Matrix();\n\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const actualMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n\n        if (renderGroup?.isCachedAsTexture)\n        {\n            bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform)\n                .append(renderable.worldTransform);\n        }\n        else if (renderGroup?._parentCacheAsTextureRenderGroup)\n        {\n            bounds.matrix = tempProjectionMatrix\n                .copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform)\n                .append(renderable.groupTransform);\n        }\n        else\n        {\n            bounds.matrix = renderable.worldTransform;\n        }\n\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = actualMatrix;\n\n    return bounds;\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { PassthroughFilter } from '../filters/defaults/passthrough/PassthroughFilter';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n\n    /** The first enabled filter index in the current filter list. */\n    public firstEnabledIndex = -1;\n\n    /** The last enabled filter index in the current filter list. */\n    public lastEnabledIndex = -1;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n    private _passthroughFilter: Filter;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        this._calculateFilterArea(instruction, bounds);\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        const globalResolution = this._findFilterResolution(rootResolution);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n        }\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        // set all the filter data\n\n        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, or all of them disabled, we skip the pass\n        if (filters.every((filter) => !filter.enabled))\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const isFinalTarget = outputRenderSurface === output;\n\n        // Find the correct resolution by looking back through the filter stack\n        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        const resolution = this._findFilterResolution(rootResolution);\n\n        // Calculate the offset for both outputFrame and globalFrame\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isFinalTarget)\n        {\n            const offset = this._findPreviousFilterOffset();\n\n            offsetX = offset.x;\n            offsetY = offset.y;\n        }\n\n        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n\n        // If the filter is disabled, we still need to write something into the output surface.\n        // Render a pass-through (copy) so the pipeline remains intact.\n        const filterToApply = filter.enabled\n            ? filter\n            : this._getPassthroughFilter();\n\n        this._setupBindGroupsAndRender(filterToApply, input, renderer);\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.orig.width,\n            1.0 / sprite.texture.orig.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        this._passthroughFilter?.destroy(true);\n        (this._passthroughFilter as null) = null;\n    }\n\n    private _getPassthroughFilter(): Filter\n    {\n        this._passthroughFilter ??= new PassthroughFilter();\n\n        return this._passthroughFilter;\n    }\n\n    /**\n     * Sets up the bind groups and renders the filter.\n     * @param filter - The filter to apply\n     * @param input - The input texture\n     * @param renderer - The renderer instance\n     */\n    private _setupBindGroupsAndRender(filter: Filter, input: Texture, renderer: Renderer): void\n    {\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(this._filterGlobalUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Sets up the filter textures including input texture and back texture if needed.\n     * @param filterData - The filter data to update\n     * @param bounds - The bounds for the texture\n     * @param renderer - The renderer instance\n     * @param previousFilterData - The previous filter data for back texture calculation\n     */\n    private _setupFilterTextures(\n        filterData: FilterData,\n        bounds: Bounds,\n        renderer: Renderer,\n        previousFilterData: FilterData | null\n    ): void\n    {\n        // set all the filter data\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        // Very cryptic, but important(!) moment.\n        //\n        // If we try to pull texture from the pool for backTexture before inputTexture,\n        // it will be unbounded later by startRenderPass. It happens because in such a case - the current backTexture\n        // is actually inputTexture from the previous filter application (check `pop` method).\n        //\n        // So maintaining the order (inputTexture -> backTexture) helps us to prevent unwanted texture unbinding.\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n\n        // set the global uniforms to take into account the bounds offset required\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Calculates and sets the global frame for the filter.\n     * @param filterData - The filter data to update\n     * @param offsetX - The X offset\n     * @param offsetY - The Y offset\n     * @param globalResolution - The global resolution\n     * @param sourceWidth - The source texture width\n     * @param sourceHeight - The source texture height\n     */\n    private _calculateGlobalFrame(\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        globalResolution: number,\n        sourceWidth: number,\n        sourceHeight: number\n    ): void\n    {\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = sourceWidth * globalResolution;\n        globalFrame.height = sourceHeight * globalResolution;\n    }\n\n    /**\n     * Updates the filter uniforms with the current filter state.\n     * @param input - The input texture\n     * @param output - The output render surface\n     * @param filterData - The current filter data\n     * @param offsetX - The X offset for positioning\n     * @param offsetY - The Y offset for positioning\n     * @param resolution - The current resolution\n     * @param isFinalTarget - Whether this is the final render target\n     * @param clear - Whether to clear the output surface\n     */\n    private _updateFilterUniforms(\n        input: Texture,\n        output: RenderSurface,\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        resolution: number,\n        isFinalTarget: boolean,\n        clear: boolean\n    ): void\n    {\n        const uniforms = this._filterGlobalUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            outputFrame[0] = filterData.bounds.minX - offsetX;\n            outputFrame[1] = filterData.bounds.minY - offsetY;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offsetX * resolution;\n        globalFrame[1] = offsetY * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        this.renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        this._filterGlobalUniforms.update();\n    }\n\n    /**\n     * Finds the correct resolution by looking back through the filter stack.\n     * @param rootResolution - The fallback root resolution to use\n     * @returns The resolution from the previous filter or root resolution\n     */\n    private _findFilterResolution(rootResolution: number): number\n    {\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture\n            ? this._filterStack[currentIndex].inputTexture.source._resolution\n            : rootResolution;\n    }\n\n    /**\n     * Finds the offset from the previous non-skipped filter in the stack.\n     * @returns The offset coordinates from the previous filter\n     */\n    private _findPreviousFilterOffset(): { x: number, y: number }\n    {\n        let offsetX = 0;\n        let offsetY = 0;\n        let lastIndex = this._filterStackIndex;\n\n        while (lastIndex > 0)\n        {\n            lastIndex--;\n            const prevFilterData = this._filterStack[lastIndex];\n\n            if (!prevFilterData.skip)\n            {\n                offsetX = prevFilterData.bounds.minX;\n                offsetY = prevFilterData.bounds.minY;\n                break;\n            }\n        }\n\n        return { x: offsetX, y: offsetY };\n    }\n\n    /**\n     * Calculates the filter area bounds based on the instruction type.\n     * @param instruction - The filter instruction\n     * @param bounds - The bounds object to populate\n     */\n    private _calculateFilterArea(instruction: FilterInstruction, bounds: Bounds): void\n    {\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n        const firstEnabled = filterData.firstEnabledIndex;\n        const lastEnabled = filterData.lastEnabledIndex;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (firstEnabled === lastEnabled)\n        {\n            // render a single filter...\n            filters[firstEnabled].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (let i = firstEnabled; i < lastEnabled; i++)\n            {\n                const filter = filters[i];\n\n                if (!filter.enabled) continue;\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n            // apply the last enabled filter to the output\n            filters[lastEnabled].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n        // cache first/last enabled indices for later passes\n        let firstEnabledIndex = -1;\n        let lastEnabledIndex = -1;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            // Only enabled filters should influence pipeline characteristics\n            if (!filter.enabled) continue;\n\n            if (firstEnabledIndex === -1) firstEnabledIndex = i;\n            lastEnabledIndex = i;\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = true;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n        filterData.firstEnabledIndex = firstEnabledIndex;\n        filterData.lastEnabledIndex = lastEnabledIndex;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 0)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\n/**\n * GPUData for Mesh\n * @internal\n */\nexport class MeshGpuData implements GPUData\n{\n    public meshData?: MeshData;\n    public batchableMesh?: BatchableMesh;\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n\n/**\n * The data for the mesh\n * @internal\n */\ninterface MeshData\n{\n    /** if the mesh is batched or not */\n    batched: boolean;\n    /** the size of the index buffer */\n    indexSize: number;\n    /** the size of the vertex buffer */\n    vertexSize: number;\n}\n\n/** @internal */\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n/**\n * The MeshPipe is responsible for handling the rendering of Mesh objects.\n * It manages the batching of meshes, updates their GPU data, and executes the rendering instructions.\n * It also handles the local uniforms for each mesh, such as transformation matrices and colors.\n * @category scene\n * @internal\n */\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const meshData = this._getMeshData(mesh);\n\n        if (mesh.didViewUpdate)\n        {\n            meshData.indexSize = mesh._geometry.indices?.length;\n            meshData.vertexSize = mesh._geometry.positions?.length;\n        }\n\n        if (meshData.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid].meshData = {\n            batched: mesh.batched,\n            indexSize: 0,\n            vertexSize: 0,\n        };\n\n        return mesh._gpuData[this.renderer.uid].meshData;\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = new BatchableMesh();\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import { type ImageLike } from '../../../environment/ImageLike';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(\n    image: ImageLike | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link PlaneGeometry}\n * @category scene\n * @advanced\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @category scene\n * @advanced\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { type PointData } from '../../maths/point/PointData';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @category scene\n * @advanced\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @category scene\n * @advanced\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    /** @internal */\n    public _leftWidth: number;\n    /** @internal */\n    public _rightWidth: number;\n    /** @internal */\n    public _topHeight: number;\n    /** @internal */\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { type GPUData } from '../view/ViewContainer';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\n/**\n * GPU data for NineSliceSprite.\n * @internal\n */\nexport class NineSliceSpriteGpuData extends BatchableMesh implements GPUData\n{\n    constructor()\n    {\n        super();\n        this.geometry = new NineSliceGeometry();\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n    }\n}\n\n/**\n * The NineSliceSpritePipe is a render pipe for rendering NineSliceSprites.\n * @internal\n */\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _managedSprites: GCManagedHash<NineSliceSprite>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._managedSprites = new GCManagedHash({ renderer, type: 'renderable', name: 'nineSliceSprite' });\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n\n        const batchableMesh = gpuData;\n\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._managedSprites.add(sprite);\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        return gpuData;\n    }\n\n    public destroy()\n    {\n        this._managedSprites.destroy();\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n * @internal\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\n/** @internal */\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\n/**\n * @param properties\n * @internal\n */\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @internal\n */\nexport interface ParticleBufferOptions\n{\n    /** The size of the particle buffer, defaults to 1000. */\n    size: number;\n    /** A record of attributes that the particle container uses. */\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer implements GPUData\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\n/** @internal */\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { GCManagedHash } from '../../../utils/data/GCManagedHash';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { ParticleContainer } from './ParticleContainer';\n\n/** @internal */\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @category scene\n * @internal\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    /** @internal */\n    public adaptor: ParticleContainerAdaptor;\n    /** @internal */\n    public readonly state = State.for2d();\n    /** @internal */\n    public readonly renderer: Renderer;\n    private readonly _managedContainers: GCManagedHash<ParticleContainer>;\n\n    /** Local uniforms that are used for rendering particles. */\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n\n        this._managedContainers = new GCManagedHash({ renderer, type: 'renderable', name: 'particleContainer' });\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        this._managedContainers.add(renderable);\n\n        return renderable._gpuData[this.renderer.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        this._managedContainers.destroy();\n        (this.renderer as null) = null;\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\n/**\n * WebGL renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\n/**\n * WebGPU renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n","import { type Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\n/**\n * The BatchableHTMLText class extends the BatchableSprite class and is used to handle HTML text rendering.\n * It includes a promise for the texture as generating the HTML texture takes some time.\n * @internal\n */\nexport class BatchableHTMLText extends BatchableSprite\n{\n    public texturePromise: Promise<Texture>;\n    public generatingTexture = false;\n    public currentKey: string = '--';\n\n    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n    public destroy()\n    {\n        this.texturePromise = null;\n        this.generatingTexture = false;\n        this.currentKey = '--';\n        super.destroy();\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { GCManagedHash } from '../../utils/data/GCManagedHash';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _managedTexts: GCManagedHash<HTMLText>;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.runners.resolutionChange.add(this);\n        this._managedTexts = new GCManagedHash({\n            renderer,\n            type: 'renderable',\n            onUnload: this.onTextUnload.bind(this),\n            name: 'htmlText'\n        });\n    }\n\n    protected resolutionChange()\n    {\n        for (const key in this._managedTexts.items)\n        {\n            const text = this._managedTexts.items[key];\n\n            if (text?._autoResolution)\n            {\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText.styleKey;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(htmlText).catch((e) =>\n                {\n                    console.error(e);\n                });\n            }\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        // We need to preserve the current texture and don't release it until the new texture is generated.\n        // It's necessary to ensure that the texture won't be captured by another field and overwritten with their\n        // content, while our texture is still in progress.\n        const oldTexturePromise = batchableHTMLText.texturePromise;\n\n        batchableHTMLText.texturePromise = null;\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        if (oldTexturePromise)\n        {\n            // Release old texture after new one is generated.\n            texturePromise = texturePromise.finally(() =>\n            {\n                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n            });\n        }\n\n        batchableHTMLText.texturePromise = texturePromise;\n        batchableHTMLText.currentKey = htmlText.styleKey;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText();\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        this._managedTexts.add(htmlText);\n\n        return batchableHTMLText;\n    }\n\n    protected onTextUnload(text: HTMLText)\n    {\n        const gpuData = text._gpuData[this._renderer.uid];\n\n        if (!gpuData) return;\n\n        const { htmlText } = this._renderer;\n\n        htmlText.getReferenceCount(gpuData.currentKey) === null\n            ? htmlText.returnTexturePromise(gpuData.texturePromise)\n            : htmlText.decreaseReferenceCount(gpuData.currentKey);\n    }\n\n    public destroy()\n    {\n        this._managedTexts.destroy();\n        this._renderer = null;\n    }\n}\n\n","/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\nimport { type ImageLike } from '../../environment/ImageLike';\n\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\n/** @internal */\nconst nssvg = 'http://www.w3.org/2000/svg';\n/** @internal */\nconst nsxhtml = 'http://www.w3.org/1999/xhtml';\n\n/** @internal */\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image: ImageLike;\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n\n        this.image = DOMAdapter.get().createImage();\n    }\n\n    public destroy(): void\n    {\n        this.svgRoot.remove();\n        this.foreignObject.remove();\n        this.styleElement.remove();\n        this.domElement.remove();\n        this.image.src = '';\n        this.image.remove();\n\n        this.svgRoot = null;\n        this.foreignObject = null;\n        this.styleElement = null;\n        this.domElement = null;\n        this.image = null;\n        this.canvasAndContext = null;\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\n/**\n * Options for the font CSS style\n * @category text\n * @internal\n */\nexport interface FontCSSStyleOptions\n{\n    /**\n     * The font family to use in the CSS\n     * @example\n     * 'Arial' or ['Arial', 'Helvetica']\n     */\n    fontFamily: string | string[]\n    /**\n     * The font weight to use in the CSS\n     * @example\n     * 'normal', 'bold', '100', '200', etc.\n     */\n    fontWeight: string\n    /**\n     * The font style to use in the CSS\n     * @example\n     * 'normal', 'italic', 'oblique'\n     */\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n * @internal\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n * @internal\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { type FontFaceCache } from '../../../assets/loader/parsers/loadWebFont';\nimport { loadFontCSS } from './loadFontCSS';\n\n/** @internal */\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @returns - The css string\n * @internal\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { entries } = Cache.get<FontFaceCache>(`${fontFamily}-and-url`);\n                const promises: Promise<string>[] = [];\n\n                entries.forEach((entry) =>\n                {\n                    const url = entry.url;\n                    const faces = entry.faces;\n\n                    const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n\n                    // load each out font with the correct style\n                    promises.push(\n                        ...out.map((style) =>\n                            loadFontCSS(\n                                {\n                                    fontWeight: style.weight,\n                                    fontStyle: style.style,\n                                    fontFamily,\n                                },\n                                url,\n                            ),\n                        ),\n                    );\n                });\n                FontStylePromiseCache.set(\n                    fontFamily,\n                    Promise.all(promises).then((css) => css.join('\\n')),\n                );\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","/* eslint-disable no-restricted-globals */\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n * @internal\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n","import { type ImageLike } from '../../environment/ImageLike';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { type HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLText, HTMLTextOptions } from './HTMLText';\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @category rendering\n * @advanced\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n        promise: Promise<Texture>,\n    }> = {};\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    /**\n     * @param options\n     * @deprecated Use getTexturePromise instead\n     */\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this.getTexturePromise(options);\n    }\n\n    /**\n     * Increases the reference count for a texture.\n     * @param text - The HTMLText instance associated with the texture.\n     */\n    public getManagedTexture(text: HTMLText): Promise<Texture>\n    {\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? null;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Decreases the reference count for a texture.\n     * If the count reaches zero, the texture is cleaned up.\n     * @param textKey - The key associated with the HTMLText instance.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture.texture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture.texture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Returns a promise that resolves to a texture for the given HTMLText options.\n     * @param options - The options for the HTMLText.\n     * @returns A promise that resolves to a Texture.\n     */\n    public getTexturePromise(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(options);\n    }\n\n    private async _buildTexturePromise(options: HTMLTextOptions)\n    {\n        const { text, style, resolution, textureStyle } = options as {\n            text: string,\n            style: HTMLTextStyle,\n            resolution: number,\n            textureStyle?: TextureStyle,\n        };\n\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(fontFamilies);\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: ImageLike | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (textureStyle) texture.source.style = textureStyle;\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    public returnTexturePromise(texturePromise: Promise<Texture>)\n    {\n        texturePromise.then((texture) =>\n        {\n            this._cleanUp(texture);\n        }).catch(() =>\n        {\n            // #if _DEBUG\n            warn('HTMLTextSystem: Failed to clean texture');\n            // #endif\n        });\n    }\n\n    private _cleanUp(texture: Texture)\n    {\n        TexturePool.returnTexture(texture, true);\n        texture.source.resource = null;\n        texture.source.uploadMethodId = 'unknown';\n    }\n\n    public destroy()\n    {\n        // BOOM!\n        (this._renderer as null) = null;\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexturePromise(this._activeTextures[key].promise);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n * @internal\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n * @internal\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","import { type ImageLike } from '../../../environment/ImageLike';\n\n/**\n * This function loads an SVG image into an IImage element.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n * @internal\n */\nexport function loadSVGImage(image: ImageLike, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\n/**\n * Checks if the current browser is Safari.\n * @returns {boolean} True if the browser is Safari, false otherwise.\n * @internal\n */\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { type ImageLike } from '../../../environment/ImageLike';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n * @internal\n */\nexport function getTemporaryCanvasFromImage(image: ImageLike, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\nimport { type TextStyle, type TextStyleOptions } from '../TextStyle';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n * @internal\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText<TextStyle, TextStyleOptions>)\n{\n    const { texture, bounds } = batchableSprite;\n    const padding = text._style._getFinalPadding();\n\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n\n    // First, calculate bounds using the full padded texture\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    // Then adjust by the padding amount to compensate for the buffer zone\n    // This shifts the render position back by the padding amount, ensuring the text\n    // appears exactly where intended while maintaining the buffer zone around it.\n    const paddingOffset = text._anchor._x * padding * 2;\n    const paddingOffsetY = text._anchor._y * padding * 2;\n\n    bounds.minX -= padding - paddingOffset;\n    bounds.minY -= padding - paddingOffsetY;\n    bounds.maxX -= padding - paddingOffset;\n    bounds.maxY -= padding - paddingOffsetY;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @category scene\n * @advanced\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @category scene\n * @advanced\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n"],"names":["BatchableText","BatchableSprite","CanvasTextPipe","constructor","renderer","this","_renderer","runners","resolutionChange","add","_managedTexts","GCManagedHash","type","onUnload","onTextUnload","bind","name","key","items","text","_autoResolution","onViewUpdate","validateRenderable","gpuText","_getGpuText","newKey","styleKey","currentKey","_didTextUpdate","addRenderable","instructionSet","batchableText","resolution","_updateGpuText","updateTextBounds","renderPipes","batch","addToBatch","updateRenderable","_batcher","updateElement","texture","canvasText","decreaseReferenceCount","_resolution","getManagedTexture","_gpuData","uid","initGpuText","renderable","transform","groupTransform","bounds","minX","maxX","minY","maxY","roundPixels","_roundPixels","gpuData","getReferenceCount","returnTexture","destroy","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","_internalCanvas","_internalContext","checkRow","data","width","y","x","index","checkColumn","top","bottom","stride","getCanvasBoundingBox","_options$resolution","_options$width","_options$height","options","arguments","length","undefined","canvas","Math","min","height","output","DOMAdapter","get","createCanvas","getContext","willReadFrequently","globalCompositeOperation","globalAlpha","nextPow2","ensureInternalCanvas","TypeError","drawImage","getImageData","left","right","Rectangle","EMPTY","strokeRect","set","tempRect","CanvasTextGenerator","getCanvasAndContext","style","padding","_getFinalPadding","measured","CanvasTextMetrics","measureText","ceil","max","canvasAndContext","CanvasPool","getOptimalCanvasAndContext","_renderTextToCanvas","frame","trim","returnCanvasAndContext","_style$_stroke","context","font","fontStringFromTextStyle","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","resetTransform","scale","textBaseline","_stroke","strokeStyle","lineWidth","miterLimit","lineJoin","join","lineCap","cap","linePositionX","linePositionY","passesCount","dropShadow","i","_style$_stroke$width","_style$_stroke3","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","shadowOptions","dropShadowColor","color","dropShadowAlpha","alpha","shadowColor","Color","shared","setValue","setAlpha","toRgbaString","dropShadowBlur","blur","dropShadowDistance","distance","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","_style$_stroke2","_fill","getCanvasFillStyle","strokePadding","linePositionYShift","fontSize","strokeWidth","i2","_style$_stroke4","ascent","align","_drawLetterSpacing","isStroke","letterSpacing","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","concat","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","j","CanvasTextSystem","_activeTextures","getTexture","_style","_textKey","deprecation","TextStyle","textureStyle","TextureStyle","toString","getPo2TextureFromSource","source","pad","copyFrom","updateUvs","filters","filteredTexture","_applyFilters","initSource","_source","resource","uploadMethodId","alphaMode","TexturePool","renderTextToCanvas","textKey","_increaseReferenceCount","usageCount","activeTexture","_this$_activeTextures","_this$_activeTextures2","currentRenderTarget","renderTarget","resultTexture","filter","generateFilteredTexture","WebGLSystem","WebGPUSystem","CanvasSystem","extensions","localUniformBit","vertex","header","main","end","localUniformBitGroup2","_objectSpread","replace","localUniformBitGl","tilingBit","fragment","tilingBitGl","gpuProgram","glProgram","TilingSpriteShader","Shader","compileHighShaderGpuProgram","bits","roundPixelsBit","compileHighShaderGlProgram","roundPixelsBitGl","tilingUniforms","UniformGroup","uMapCoord","value","Matrix","uClampFrame","Float32Array","uClampOffset","uTextureTransform","uSizeAnchor","resources","localUniforms","uTransformMatrix","uColor","uRound","uTexture","Texture","uSampler","updateUniforms","matrix","anchorX","anchorY","textureWidth","textureHeight","textureMatrix","uniforms","a","b","c","d","tx","ty","invert","mapCoord","QuadGeometry","MeshGeometry","positions","uvs","indices","Uint32Array","sharedQuad","TilingSpriteGpuData","canBatch","geometry","slice","_this$shader","shader","TilingSpritePipe","_state","State","default2d","_managedTilingSprites","tilingSpriteData","_getTilingSpriteData","couldBatch","_updateCanBatch","batchableMesh","checkAndUpdateTexture","tilingSprite","batcher","BatchableMesh","didViewUpdate","_updateBatchableMesh","setTexture","_texture","break","execute","groups","globalUniforms","bindGroup","color32BitToUniform","groupColorAlpha","blendMode","getAdjustedBlendModeBlend","groupBlendMode","encoder","draw","state","_tileTransform","anchor","_initTilingSpriteData","renderableData","addressMode","update","applyAnchorToTexture","array","offset","size","applyMatrix","setUvs","setPositions","_nonPowOf2wrapping","RendererType","WEBGL","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo","batcherName","packAsQuad","indexOffset","attributeOffset","_batch","_textureMatrixUpdateId","_uvUpdateId","topology","_topology","reset","uvBuffer","getBuffer","transformedUvs","_transformedUvs","_updateID","multiplyUvs","attributeSize","indexSize","_attributeStart","GraphicsGpuData","batches","batched","forEach","BigPool","return","GraphicsPipe","adaptor","for2d","_adaptor","contextChange","_managedGraphics","priority","graphics","wasBatched","gpuContext","graphicsContext","updateGpuContext","isBatchable","_rebuild","_addToBatcher","_getGpuDataForRenderable","isRenderable","getGpuContext","customShader","_updateBatchesForRenderable","batchPipe","_initGpuDataForRenderable","map","batchClone","BatchableGraphics","copyTo","GraphicsContextSystem","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","maxTextures","uDistance","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","getBatchSamplersUniformGroup","BitmapTextGraphics","Graphics","super","BitmapTextPipe","_managedBitmapTexts","bitmapText","graphicsRenderable","_getGpuBitmapText","syncWithProxy","_updateContext","_updateDistanceField","proxyGraphics","bitmapFont","BitmapFontManager","getFont","clear","distanceField","limits","maxBatchableTextures","chars","currentY","baseLineOffset","bitmapTextLayout","getBitmapTextLayout","offsetY","translate","_anchor","_x","_y","tint","applyFillAsTint","fontMetrics","line","charPositions","char","charData","round","xOffset","yOffset","orig","proxyRenderable","fontFamily","dynamicFont","Cache","dx","sqrt","dy","worldScale","abs","fontScale","baseRenderedFontSize","range","container","proxy","groupColor","globalDisplayStatus","localDisplayStatus","groupAlpha","FilterPipe","push","filterEffect","renderPipeId","canBundle","action","pop","_filterEffect","_container","instruction","PassthroughFilter","Filter","GpuProgram","from","entryPoint","GlProgram","tempProjectionMatrix","quadGeometry","Geometry","attributes","aPosition","buffer","format","indexBuffer","FilterData","skip","inputTexture","backTexture","Bounds","blendRequired","outputRenderSurface","globalFrame","firstEnabledIndex","lastEnabledIndex","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","BindGroup","activeBackTexture","_this$_activeFilterDa","_activeFilterData","filterData","_pushFilterData","renderSurface","colorTextureSource","colorTexture","rootResolution","rootAntialias","antialias","every","enabled","_calculateFilterArea","_calculateFilterBounds","rootViewPort","previousFilterData","_getPreviousFilterData","globalResolution","_findFilterResolution","offsetX","_calculateGlobalFrame","_setupFilterTextures","_ref","addRect","rectangle","getOptimalTexture","finishRenderPass","_applyFiltersToTexture","outputTexture","_popFilterData","getBackTexture","lastRenderSurface","previousBounds","backgroundResolution","floor","copyToTexture","applyFilter","input","isFinalTarget","rootRenderTarget","_findPreviousFilterOffset","_updateFilterUniforms","filterToApply","_getPassthroughFilter","_setupBindGroupsAndRender","calculateSpriteMatrix","outputMatrix","sprite","mappedMatrix","worldTransform","renderGroup","parentRenderGroup","cacheToLocalTransform","prepend","_this$_passthroughFil","_passthroughFilter","_this$_passthroughFil2","uniformBatch","batchUniforms","getUboResource","setResource","getRenderTarget","sourceWidth","sourceHeight","outputFrame","inputSize","inputPixel","inputClamp","pixelWidth","pixelHeight","rootTexture","isRoot","currentIndex","lastIndex","prevFilterData","renderables","actualMatrix","_renderable$renderGro","isCachedAsTexture","textureOffsetInverseTransform","append","_parentCacheAsTextureRenderGroup","inverseWorldTransform","addBounds","getGlobalRenderableBounds","filterArea","getFastGlobalBounds","filterFrameTransform","firstEnabled","lastEnabled","apply","flip","tempTexture","flop","t","viewPort","paddingMultiplier","Infinity","clipToViewport","_renderer$backBuffer$","_renderer$backBuffer","compatibleRenderers","backBuffer","useBackBuffer","warn","fitBounds","isPositive","MeshGpuData","MeshPipe","localUniformsBindGroup","init","mesh","meshData","_getMeshData","isBatched","_geometry","vertexSize","_getBatchableMesh","_mesh$_geometry$indic","_mesh$_geometry$posit","gpuBatchableMesh","_a","_b","_initMeshData","_initBatchableMesh","gpuMesh","tempBounds","image","emit","_PlaneGeometry","v8_0_0","verticesX","verticesY","build","_this$verticesX","_this$verticesY","_this$width","_this$height","defaultOptions","total","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","PlaneGeometry","_NineSliceGeometry","_options$originalWidt","_options$originalHeig","_options$leftWidth","_options$rightWidth","_options$topHeight","_options$bottomHeight","_options$anchor","_options$anchor2","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updatePositions","p","w","scaleW","h","scaleH","anchorOffsetX","anchorOffsetY","_uvw","_uvh","NineSliceGeometry","NineSliceSpriteGpuData","NineSliceSpritePipe","_managedSprites","gpuSprite","_getGpuSprite","_updateBatchableSprite","batchableSprite","_initGPUSprite","GlParticleContainerAdaptor","particleContainerPipe","defaultShader","gl","getBuffers","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","Uint16Array","Error","generateUpdateFunction","properties","dynamic","funcFragments","property","code","getAttributeInfoFromFormat","unshift","functionSource","Function","ParticleBuffer","_options$size","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","Buffer","label","shrinkToFit","usage","BufferUsage","VERTEX","COPY_DST","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","ParticleShader","wgsl","WHITE","uTranslationMatrix","uResolution","ParticleContainerPipe","_managedContainers","_renderable","_initBuffer","_properties","children","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe","BatchableHTMLText","generatingTexture","texturePromise","HTMLTextPipe","htmlText","batchableHTMLText","catch","e","console","error","oldTexturePromise","getTexturePromise","finally","returnTexturePromise","structureDidChange","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","setAttribute","overflow","appendChild","createImage","remove","src","loadFontCSS","url","dataSrc","response","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","result","onerror","readAsDataURL","loadFontAsBase64","fontWeight","fontStyle","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_createCanvas","WEBGPU","promise","_buildTexturePromise","then","_cleanUp","htmlTextData","fontFamilies","dedupe","matches","match","addFontFamily","fontFamily2","Array","isArray","split","tagStyles","extractFontFamilies","fontCSS","fontPromises","has","entries","promises","entry","out","faces","face","weight","all","css","getFontCss","fontStyleCSS","htmlTextRenderData","innerHTML","cssStyle","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","svgURL","XMLSerializer","serializeToString","getSVGUrl","delay","async","resolve2","setTimeout","onload","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","test","isSafari","clearRect","getTemporaryCanvasFromImage","updateQuadBounds","paddingOffset","paddingOffsetY","ResizePlugin","TickerPlugin","abgr","_MeshGeometry","shrinkBuffersToFit","aUV","INDEX","batchMode"],"ignoreList":[],"sourceRoot":""}