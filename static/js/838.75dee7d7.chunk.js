"use strict";(self.webpackChunkmap=self.webpackChunkmap||[]).push([[838],{64(e,t,r){var n=r(1478),i=r(4745),a=r(6595),o=r(1669);class s extends o.K{}class u{constructor(e){this._renderer=e,e.runners.resolutionChange.add(this),this._managedTexts=new i.s({renderer:e,type:"renderable",onUnload:this.onTextUnload.bind(this),name:"canvasText"})}resolutionChange(){for(const e in this._managedTexts.items){const t=this._managedTexts.items[e];null!==t&&void 0!==t&&t._autoResolution&&t.onViewUpdate()}}validateRenderable(e){const t=this._getGpuText(e),r=e.styleKey;return t.currentKey!==r||e._didTextUpdate}addRenderable(e,t){const r=this._getGpuText(e);if(e._didTextUpdate){const t=e._autoResolution?this._renderer.resolution:e.resolution;r.currentKey===e.styleKey&&e.resolution===t||this._updateGpuText(e),e._didTextUpdate=!1,(0,a.s)(r,e)}this._renderer.renderPipes.batch.addToBatch(r,t)}updateRenderable(e){const t=this._getGpuText(e);t._batcher.updateElement(t)}_updateGpuText(e){const t=this._getGpuText(e);t.texture&&this._renderer.canvasText.decreaseReferenceCount(t.currentKey),e._resolution=e._autoResolution?this._renderer.resolution:e.resolution,t.texture=this._renderer.canvasText.getManagedTexture(e),t.currentKey=e.styleKey}_getGpuText(e){return e._gpuData[this._renderer.uid]||this.initGpuText(e)}initGpuText(e){const t=new s;return t.currentKey="--",t.renderable=e,t.transform=e.groupTransform,t.bounds={minX:0,maxX:1,minY:0,maxY:0},t.roundPixels=this._renderer._roundPixels|e._roundPixels,e._gpuData[this._renderer.uid]=t,this._managedTexts.add(e),t}onTextUnload(e){const t=e._gpuData[this._renderer.uid];if(!t)return;const{canvasText:r}=this._renderer;r.getReferenceCount(t.currentKey)>0?r.decreaseReferenceCount(t.currentKey):t.texture&&r.returnTexture(t.texture)}destroy(){this._managedTexts.destroy(),this._renderer=null}}u.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"text"};var l=r(3202),d=r(879),c=r(4811),h=r(2100),p=r(4749),f=r(5242),m=r(4307),g=r(9445),x=r(3144),v=r(8186);let _=null,b=null;function y(e,t,r){for(let n=0,i=4*r*t;n<t;++n,i+=4)if(0!==e[i+3])return!1;return!0}function T(e,t,r,n,i){const a=4*t;for(let o=n,s=n*a+4*r;o<=i;++o,s+=a)if(0!==e[s+3])return!1;return!0}function w(){var e,t,r;let n=arguments.length<=0?void 0:arguments[0];n.canvas||(n={canvas:arguments.length<=0?void 0:arguments[0],resolution:arguments.length<=1?void 0:arguments[1]});const{canvas:i}=n,a=Math.min(null!==(e=n.resolution)&&void 0!==e?e:1,1),o=null!==(t=n.width)&&void 0!==t?t:i.width,s=null!==(r=n.height)&&void 0!==r?r:i.height;let u=n.output;if(function(e,t){_||(_=x.e.get().createCanvas(256,128),b=_.getContext("2d",{willReadFrequently:!0}),b.globalCompositeOperation="copy",b.globalAlpha=1),(_.width<e||_.height<t)&&(_.width=(0,v.U5)(e),_.height=(0,v.U5)(t))}(o,s),!b)throw new TypeError("Failed to get canvas 2D context");b.drawImage(i,0,0,o,s,0,0,o*a,s*a);const l=b.getImageData(0,0,o,s).data;let d=0,c=0,h=o-1,p=s-1;for(;c<s&&y(l,o,c);)++c;if(c===s)return m.M.EMPTY;for(;y(l,o,p);)--p;for(;T(l,o,d,c,p);)++d;for(;T(l,o,h,c,p);)--h;return++h,++p,b.globalCompositeOperation="source-over",b.strokeRect(d,c,h-d,p-c),b.globalCompositeOperation="copy",null!==u&&void 0!==u||(u=new m.M),u.set(d/a,c/a,(h-d)/a,(p-c)/a),u}var C=r(7821),S=r(1915),P=r(5435);const U=new m.M;const R=new class{getCanvasAndContext(e){const{text:t,style:r,resolution:n=1}=e,i=r._getFinalPadding(),a=C.P.measureText(t||" ",r),o=Math.ceil(Math.ceil(Math.max(1,a.width)+2*i)*n),s=Math.ceil(Math.ceil(Math.max(1,a.height)+2*i)*n),u=g.N.getOptimalCanvasAndContext(o,s);this._renderTextToCanvas(t,r,i,n,u);return{canvasAndContext:u,frame:r.trim?w({canvas:u.canvas,width:o,height:s,resolution:1,output:U}):U.set(0,0,o,s)}}returnCanvasAndContext(e){g.N.returnCanvasAndContext(e)}_renderTextToCanvas(e,t,r,n,i){var a;const{canvas:o,context:s}=i,u=(0,S.Z)(t),l=C.P.measureText(e||" ",t),d=l.lines,c=l.lineHeight,h=l.lineWidths,p=l.maxLineWidth,m=l.fontProperties,g=o.height;if(s.resetTransform(),s.scale(n,n),s.textBaseline=t.textBaseline,null!==(a=t._stroke)&&void 0!==a&&a.width){const e=t._stroke;s.lineWidth=e.width,s.miterLimit=e.miterLimit,s.lineJoin=e.join,s.lineCap=e.cap}let x,v;s.font=u;const _=t.dropShadow?2:1;for(let C=0;C<_;++C){var b,y;const e=t.dropShadow&&0===C,a=e?Math.ceil(Math.max(1,g)+2*r):0,o=a*n;if(e){s.fillStyle="black",s.strokeStyle="black";const e=t.dropShadow,r=e.color,i=e.alpha;s.shadowColor=f.Q.shared.setValue(r).setAlpha(i).toRgbaString();const a=e.blur*n,u=e.distance*n;s.shadowBlur=a,s.shadowOffsetX=Math.cos(e.angle)*u,s.shadowOffsetY=Math.sin(e.angle)*u+o}else{var T;if(s.fillStyle=t._fill?(0,P.r)(t._fill,s,l,2*r):null,null!==(T=t._stroke)&&void 0!==T&&T.width){const e=.5*t._stroke.width+2*r;s.strokeStyle=(0,P.r)(t._stroke,s,l,e)}s.shadowColor="black"}let u=(c-m.fontSize)/2;c-m.fontSize<0&&(u=0);const _=null!==(b=null===(y=t._stroke)||void 0===y?void 0:y.width)&&void 0!==b?b:0;for(let n=0;n<d.length;n++){var w;x=_/2,v=_/2+n*c+m.ascent+u,"right"===t.align?x+=p-h[n]:"center"===t.align&&(x+=(p-h[n])/2),null!==(w=t._stroke)&&void 0!==w&&w.width&&this._drawLetterSpacing(d[n],t,i,x+r,v+r-a,!0),void 0!==t._fill&&this._drawLetterSpacing(d[n],t,i,x+r,v+r-a)}}}_drawLetterSpacing(e,t,r,n,i){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const{context:o}=r,s=t.letterSpacing;let u=!1;if(C.P.experimentalLetterSpacingSupported&&(C.P.experimentalLetterSpacing?(o.letterSpacing="".concat(s,"px"),o.textLetterSpacing="".concat(s,"px"),u=!0):(o.letterSpacing="0px",o.textLetterSpacing="0px")),0===s||u)return void(a?o.strokeText(e,n,i):o.fillText(e,n,i));let l=n;const d=C.P.graphemeSegmenter(e);let c=o.measureText(e).width,h=0;for(let p=0;p<d.length;++p){const e=d[p];a?o.strokeText(e,l,i):o.fillText(e,l,i);let t="";for(let r=p+1;r<d.length;++r)t+=d[r];h=o.measureText(t).width,l+=c-h+s,c=h}}};class F{constructor(e){this._activeTextures={},this._renderer=e}getTexture(e,t,r,n){var i;"string"===typeof e&&((0,c.t6)("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),e={text:e,style:r,resolution:t}),e.style instanceof h.x||(e.style=new h.x(e.style)),e.textureStyle instanceof d.n||(e.textureStyle=new d.n(e.textureStyle)),"string"!==typeof e.text&&(e.text=e.text.toString());const{text:a,style:o,textureStyle:s}=e,u=null!==(i=e.resolution)&&void 0!==i?i:this._renderer.resolution,{frame:l,canvasAndContext:f}=R.getCanvasAndContext({text:a,style:o,resolution:u}),m=(0,p.M)(f.canvas,l.width,l.height,u);if(s&&(m.source.style=s),o.trim&&(l.pad(o.padding),m.frame.copyFrom(l),m.frame.scale(1/u),m.updateUvs()),o.filters){const e=this._applyFilters(m,o.filters);return this.returnTexture(m),R.returnCanvasAndContext(f),e}return this._renderer.texture.initSource(m._source),R.returnCanvasAndContext(f),m}returnTexture(e){const t=e.source;t.resource=null,t.uploadMethodId="unknown",t.alphaMode="no-premultiply-alpha",l.W.returnTexture(e,!0)}renderTextToCanvas(){(0,c.t6)("8.10.0","CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead")}getManagedTexture(e){e._resolution=e._autoResolution?this._renderer.resolution:e.resolution;const t=e.styleKey;if(this._activeTextures[t])return this._increaseReferenceCount(t),this._activeTextures[t].texture;const r=this.getTexture({text:e.text,style:e.style,resolution:e._resolution,textureStyle:e.textureStyle});return this._activeTextures[t]={texture:r,usageCount:1},r}decreaseReferenceCount(e){const t=this._activeTextures[e];t.usageCount--,0===t.usageCount&&(this.returnTexture(t.texture),this._activeTextures[e]=null)}getReferenceCount(e){var t,r;return null!==(t=null===(r=this._activeTextures[e])||void 0===r?void 0:r.usageCount)&&void 0!==t?t:0}_increaseReferenceCount(e){this._activeTextures[e].usageCount++}_applyFilters(e,t){const r=this._renderer.renderTarget.renderTarget,n=this._renderer.filter.generateFilteredTexture({texture:e,filters:t});return this._renderer.renderTarget.bind(r,!1),n}destroy(){this._renderer=null;for(const e in this._activeTextures)this._activeTextures[e]&&this.returnTexture(this._activeTextures[e].texture);this._activeTextures=null}}F.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem,n.Ag.CanvasSystem],name:"canvasText"},n.XO.add(F),n.XO.add(u)},454(e,t,r){r.d(t,{Ls:()=>i,_Q:()=>a,mA:()=>o});var n=r(2555);const i={name:"local-uniform-bit",vertex:{header:"\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "}},a=(0,n.A)((0,n.A)({},i),{},{vertex:(0,n.A)((0,n.A)({},i.vertex),{},{header:i.vertex.header.replace("group(1)","group(2)")})}),o={name:"local-uniform-bit",vertex:{header:"\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "}}},464(e,t,r){var n=r(1478),i=r(2080),a=r(576),o=r(6650),s=r(4745),u=r(9385),l=r(475),d=r(9859),c=r(3596),h=r(9569),p=r(454),f=r(4994),m=r(3636),g=r(5222),x=r(5705);const v={name:"tiling-bit",vertex:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        "},fragment:{header:"\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        ",main:"\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        "}},_={name:"tiling-bit",vertex:{header:"\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        ",main:"\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        "},fragment:{header:"\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        ",main:"\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        "}};let b,y;class T extends m.M{constructor(){null!==b&&void 0!==b||(b=(0,h.v)({name:"tiling-sprite-shader",bits:[p.Ls,v,f.b]})),null!==y&&void 0!==y||(y=(0,h.I)({name:"tiling-sprite-shader",bits:[p.mA,_,f.m]}));const e=new g.k({uMapCoord:{value:new c.u,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new c.u,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:y,gpuProgram:b,resources:{localUniforms:new g.k({uTransformMatrix:{value:new c.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:e,uTexture:x.g.EMPTY.source,uSampler:x.g.EMPTY.source.style}})}updateUniforms(e,t,r,n,i,a){const o=this.resources.tilingUniforms,s=a.width,u=a.height,l=a.textureMatrix,d=o.uniforms.uTextureTransform;d.set(r.a*s/e,r.b*s/t,r.c*u/e,r.d*u/t,r.tx/e,r.ty/t),d.invert(),o.uniforms.uMapCoord=l.mapCoord,o.uniforms.uClampFrame=l.uClampFrame,o.uniforms.uClampOffset=l.uClampOffset,o.uniforms.uTextureTransform=d,o.uniforms.uSizeAnchor[0]=e,o.uniforms.uSizeAnchor[1]=t,o.uniforms.uSizeAnchor[2]=n,o.uniforms.uSizeAnchor[3]=i,a&&(this.resources.uTexture=a.source,this.resources.uSampler=a.source.style)}}class w extends d.u{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}const C=new w;class S{constructor(){this.canBatch=!0,this.geometry=new d.u({indices:C.indices.slice(),positions:C.positions.slice(),uvs:C.uvs.slice()})}destroy(){var e;this.geometry.destroy(),null===(e=this.shader)||void 0===e||e.destroy()}}class P{constructor(e){this._state=a.U.default2d,this._renderer=e,this._managedTilingSprites=new s.s({renderer:e,type:"renderable",name:"tilingSprite"})}validateRenderable(e){const t=this._getTilingSpriteData(e),r=t.canBatch;this._updateCanBatch(e);const n=t.canBatch;if(n&&n===r){const{batchableMesh:r}=t;return!r._batcher.checkAndUpdateTexture(r,e.texture)}return r!==n}addRenderable(e,t){const r=this._renderer.renderPipes.batch;this._updateCanBatch(e);const n=this._getTilingSpriteData(e),{geometry:i,canBatch:a}=n;if(a){n.batchableMesh||(n.batchableMesh=new l.U);const a=n.batchableMesh;e.didViewUpdate&&(this._updateBatchableMesh(e),a.geometry=i,a.renderable=e,a.transform=e.groupTransform,a.setTexture(e._texture)),a.roundPixels=this._renderer._roundPixels|e._roundPixels,r.addToBatch(a,t)}else r.break(t),n.shader||(n.shader=new T),this.updateRenderable(e),t.add(e)}execute(e){const{shader:t}=this._getTilingSpriteData(e);t.groups[0]=this._renderer.globalUniforms.bindGroup;const r=t.resources.localUniforms.uniforms;r.uTransformMatrix=e.groupTransform,r.uRound=this._renderer._roundPixels|e._roundPixels,(0,u.V)(e.groupColorAlpha,r.uColor,0),this._state.blendMode=(0,i.i)(e.groupBlendMode,e.texture._source),this._renderer.encoder.draw({geometry:C,shader:t,state:this._state})}updateRenderable(e){const t=this._getTilingSpriteData(e),{canBatch:r}=t;if(r){const{batchableMesh:r}=t;e.didViewUpdate&&this._updateBatchableMesh(e),r._batcher.updateElement(r)}else if(e.didViewUpdate){const{shader:r}=t;r.updateUniforms(e.width,e.height,e._tileTransform.matrix,e.anchor.x,e.anchor.y,e.texture)}}_getTilingSpriteData(e){return e._gpuData[this._renderer.uid]||this._initTilingSpriteData(e)}_initTilingSpriteData(e){const t=new S;return t.renderable=e,e._gpuData[this._renderer.uid]=t,this._managedTilingSprites.add(e),t}_updateBatchableMesh(e){const t=this._getTilingSpriteData(e),{geometry:r}=t,n=e.texture.source.style;"repeat"!==n.addressMode&&(n.addressMode="repeat",n.update()),function(e,t){const r=e.texture,n=r.frame.width,i=r.frame.height;let a=0,o=0;e.applyAnchorToTexture&&(a=e.anchor.x,o=e.anchor.y),t[0]=t[6]=-a,t[2]=t[4]=1-a,t[1]=t[3]=-o,t[5]=t[7]=1-o;const s=c.u.shared;s.copyFrom(e._tileTransform.matrix),s.tx/=e.width,s.ty/=e.height,s.invert(),s.scale(e.width/n,e.height/i),function(e,t,r,n){let i=0;const a=e.length/(t||2),o=n.a,s=n.b,u=n.c,l=n.d,d=n.tx,c=n.ty;for(r*=t;i<a;){const n=e[r],a=e[r+1];e[r]=o*n+u*a+d,e[r+1]=s*n+l*a+c,r+=t,i++}}(t,2,0,s)}(e,r.uvs),function(e,t){const r=e.anchor.x,n=e.anchor.y;t[0]=-r*e.width,t[1]=-n*e.height,t[2]=(1-r)*e.width,t[3]=-n*e.height,t[4]=(1-r)*e.width,t[5]=(1-n)*e.height,t[6]=-r*e.width,t[7]=(1-n)*e.height}(e,r.positions)}destroy(){this._managedTilingSprites.destroy(),this._renderer=null}_updateCanBatch(e){const t=this._getTilingSpriteData(e),r=e.texture;let n=!0;return this._renderer.type===o.W.WEBGL&&(n=this._renderer.context.supports.nonPowOf2wrapping),t.canBatch=r.textureMatrix.isSimple&&(n||r.source.isPowerOfTwo),t.canBatch}}P.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"tilingSprite"},n.XO.add(P)},475(e,t,r){r.d(t,{U:()=>n});class n{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._textureMatrixUpdateId=-1,this._uvUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(e){this._topology=e}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}setTexture(e){this.texture!==e&&(this.texture=e,this._textureMatrixUpdateId=-1)}get uvs(){const e=this.geometry.getBuffer("aUV"),t=e.data;let r=t;const n=this.texture.textureMatrix;return n.isSimple||(r=this._transformedUvs,this._textureMatrixUpdateId===n._updateID&&this._uvUpdateId===e._updateID||((!r||r.length<t.length)&&(r=this._transformedUvs=new Float32Array(t.length)),this._textureMatrixUpdateId=n._updateID,this._uvUpdateId=e._updateID,n.multiplyUvs(t,r))),r}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}},1669(e,t,r){r.d(t,{K:()=>n});class n{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}destroy(){this.reset()}}},1878(e,t,r){var n=r(1478),i=r(9530),a=r(576),o=r(4745),s=r(2521),u=r(9385),l=r(9211);class d{constructor(){this.batches=[],this.batched=!1}destroy(){this.batches.forEach(e=>{s.Z.return(e)}),this.batches.length=0}}class c{constructor(e,t){this.state=a.U.for2d(),this.renderer=e,this._adaptor=t,this.renderer.runners.contextChange.add(this),this._managedGraphics=new o.s({renderer:e,type:"renderable",priority:-1,name:"graphics"})}contextChange(){this._adaptor.contextChange(this.renderer)}validateRenderable(e){const t=e.context,r=!!e._gpuData,n=this.renderer.graphicsContext.updateGpuContext(t);return!(!n.isBatchable&&r===n.isBatchable)}addRenderable(e,t){const r=this.renderer.graphicsContext.updateGpuContext(e.context);e.didViewUpdate&&this._rebuild(e),r.isBatchable?this._addToBatcher(e,t):(this.renderer.renderPipes.batch.break(t),t.add(e))}updateRenderable(e){const t=this._getGpuDataForRenderable(e).batches;for(let r=0;r<t.length;r++){const e=t[r];e._batcher.updateElement(e)}}execute(e){if(!e.isRenderable)return;const t=this.renderer,r=e.context;if(!t.graphicsContext.getGpuContext(r).batches.length)return;const n=r.customShader||this._adaptor.shader;this.state.blendMode=e.groupBlendMode;const i=n.resources.localUniforms.uniforms;i.uTransformMatrix=e.groupTransform,i.uRound=t._roundPixels|e._roundPixels,(0,u.V)(e.groupColorAlpha,i.uColor,0),this._adaptor.execute(this,e)}_rebuild(e){const t=this._getGpuDataForRenderable(e),r=this.renderer.graphicsContext.updateGpuContext(e.context);t.destroy(),r.isBatchable&&this._updateBatchesForRenderable(e,t)}_addToBatcher(e,t){const r=this.renderer.renderPipes.batch,n=this._getGpuDataForRenderable(e).batches;for(let i=0;i<n.length;i++){const e=n[i];r.addToBatch(e,t)}}_getGpuDataForRenderable(e){return e._gpuData[this.renderer.uid]||this._initGpuDataForRenderable(e)}_initGpuDataForRenderable(e){const t=new d;return e._gpuData[this.renderer.uid]=t,this._managedGraphics.add(e),t}_updateBatchesForRenderable(e,t){const r=e.context,n=this.renderer.graphicsContext.getGpuContext(r),i=this.renderer._roundPixels|e._roundPixels;t.batches=n.batches.map(t=>{const r=s.Z.get(l.G);return t.copyTo(r),r.renderable=e,r.roundPixels=i,r})}destroy(){this._managedGraphics.destroy(),this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null}}c.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"graphics"},n.XO.add(c),n.XO.add(i.GH)},1963(e,t,r){var n=r(1478),i=r(8656),a=r(4745),o=r(4395),s=r(7821),u=r(3596),l=r(9569),d=r(763),c=r(1193),h=r(4994),p=r(9963),f=r(3636),m=r(5222);const g={name:"local-uniform-msdf-bit",vertex:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",main:"\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",end:"\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        "},fragment:{header:"\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         ",main:"\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        "}},x={name:"local-uniform-msdf-bit",vertex:{header:"\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",main:"\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        ",end:"\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        "},fragment:{header:"\n            uniform float uDistance;\n         ",main:"\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        "}},v={name:"msdf-bit",fragment:{header:"\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        "}},_={name:"msdf-bit",fragment:{header:"\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        "}};let b,y;class T extends f.M{constructor(e){const t=new m.k({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new u.u,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}});null!==b&&void 0!==b||(b=(0,l.v)({name:"sdf-shader",bits:[d.F,(0,c._)(e),g,v,h.b]})),null!==y&&void 0!==y||(y=(0,l.I)({name:"sdf-shader",bits:[d.a,(0,c.P)(e),x,_,h.m]})),super({glProgram:y,gpuProgram:b,resources:{localUniforms:t,batchSamplers:(0,p.n)(e)}})}}var w=r(4048),C=r(5310);class S extends o.A{destroy(){this.context.customShader&&this.context.customShader.destroy(),super.destroy()}}class P{constructor(e){this._renderer=e,this._managedBitmapTexts=new a.s({renderer:e,type:"renderable",priority:-2,name:"bitmapText"})}validateRenderable(e){const t=this._getGpuBitmapText(e);return this._renderer.renderPipes.graphics.validateRenderable(t)}addRenderable(e,t){const r=this._getGpuBitmapText(e);U(e,r),e._didTextUpdate&&(e._didTextUpdate=!1,this._updateContext(e,r)),this._renderer.renderPipes.graphics.addRenderable(r,t),r.context.customShader&&this._updateDistanceField(e)}updateRenderable(e){const t=this._getGpuBitmapText(e);U(e,t),this._renderer.renderPipes.graphics.updateRenderable(t),t.context.customShader&&this._updateDistanceField(e)}_updateContext(e,t){const{context:r}=t,n=w.c.getFont(e.text,e._style);r.clear(),"none"!==n.distanceField.type&&(r.customShader||(r.customShader=new T(this._renderer.limits.maxBatchableTextures)));const i=s.P.graphemeSegmenter(e.text),a=e._style;let o=n.baseLineOffset;const u=(0,C.Z)(i,a,n,!0),l=a.padding,d=u.scale;let c=u.width,h=u.height+u.offsetY;a._stroke&&(c+=a._stroke.width/d,h+=a._stroke.width/d),r.translate(-e._anchor._x*c-l,-e._anchor._y*h-l).scale(d,d);const p=n.applyFillAsTint?a._fill.color:16777215;let f=n.fontMetrics.fontSize,m=n.lineHeight;a.lineHeight&&(f=a.fontSize/d,m=a.lineHeight/d);let g=(m-f)/2;g-n.baseLineOffset<0&&(g=0);for(let s=0;s<u.lines.length;s++){const e=u.lines[s];for(let t=0;t<e.charPositions.length;t++){const i=e.chars[t],a=n.chars[i];if(null!==a&&void 0!==a&&a.texture){const n=a.texture;r.texture(n,p||"black",Math.round(e.charPositions[t]+a.xOffset),Math.round(o+a.yOffset+g),n.orig.width,n.orig.height)}}o+=m}}_getGpuBitmapText(e){return e._gpuData[this._renderer.uid]||this.initGpuText(e)}initGpuText(e){const t=new S;return e._gpuData[this._renderer.uid]=t,this._updateContext(e,t),this._managedBitmapTexts.add(e),t}_updateDistanceField(e){const t=this._getGpuBitmapText(e).context,r=e._style.fontFamily,n=i.l.get("".concat(r,"-bitmap")),{a:a,b:o,c:s,d:u}=e.groupTransform,l=Math.sqrt(a*a+o*o),d=Math.sqrt(s*s+u*u),c=(Math.abs(l)+Math.abs(d))/2,h=n.baseRenderedFontSize/e._style.fontSize,p=c*n.distanceField.range*(1/h);t.customShader.resources.localUniforms.uniforms.uDistance=p}destroy(){this._managedBitmapTexts.destroy(),this._renderer=null,this._managedBitmapTexts=null}}function U(e,t){t.groupTransform=e.groupTransform,t.groupColorAlpha=e.groupColorAlpha,t.groupColor=e.groupColor,t.groupBlendMode=e.groupBlendMode,t.globalDisplayStatus=e.globalDisplayStatus,t.groupTransform=e.groupTransform,t.localDisplayStatus=e.localDisplayStatus,t.groupAlpha=e.groupAlpha,t._roundPixels=e._roundPixels}P.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"bitmapText"},n.XO.add(P)},3896(e,t,r){var n=r(1478);class i{constructor(e){this._renderer=e}push(e,t,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:t,filterEffect:e})}pop(e,t,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(e){"pushFilter"===e.action?this._renderer.filter.push(e):"popFilter"===e.action&&this._renderer.filter.pop()}destroy(){this._renderer=null}}i.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"filter"};var a=r(5920),o=r(7699),s=r(2761),u="struct GlobalFilterUniforms {\n  uInputSize: vec4<f32>,\n  uInputPixel: vec4<f32>,\n  uInputClamp: vec4<f32>,\n  uOutputFrame: vec4<f32>,\n  uGlobalFrame: vec4<f32>,\n  uOutputTexture: vec4<f32>,\n};\n\n@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler: sampler;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>\n};\n\nfn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition: vec2<f32>,\n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n    return textureSample(uTexture, uSampler, uv);\n}\n";class l extends s.d{constructor(){super({gpuProgram:o.B.from({vertex:{source:u,entryPoint:"mainVertex"},fragment:{source:u,entryPoint:"mainFragment"},name:"passthrough-filter"}),glProgram:a.M.from({vertex:"in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",fragment:"in vec2 vTextureCoord;\nout vec4 finalColor;\nuniform sampler2D uTexture;\nvoid main() {\n    finalColor = texture(uTexture, vTextureCoord);\n}\n",name:"passthrough-filter"})})}}var d=r(3596),c=r(2590),h=r(9801),p=r(5222),f=r(5705),m=r(3202),g=r(6650),x=r(6373);const v=new d.u;var _=r(279);const b=new h.V({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class y{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new x.c,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0},this.firstEnabledIndex=-1,this.lastEnabledIndex=-1}}class T{constructor(e){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new p.k({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new c.T({}),this.renderer=e}get activeBackTexture(){var e;return null===(e=this._activeFilterData)||void 0===e?void 0:e.backTexture}push(e){const t=this.renderer,r=e.filterEffect.filters,n=this._pushFilterData();n.skip=!1,n.filters=r,n.container=e.container,n.outputRenderSurface=t.renderTarget.renderSurface;const i=t.renderTarget.renderTarget.colorTexture.source,a=i.resolution,o=i.antialias;if(r.every(e=>!e.enabled))return void(n.skip=!0);const s=n.bounds;if(this._calculateFilterArea(e,s),this._calculateFilterBounds(n,t.renderTarget.rootViewPort,o,a,1),n.skip)return;const u=this._getPreviousFilterData(),l=this._findFilterResolution(a);let d=0,c=0;u&&(d=u.bounds.minX,c=u.bounds.minY),this._calculateGlobalFrame(n,d,c,l,i.width,i.height),this._setupFilterTextures(n,s,t,u)}generateFilteredTexture(e){let{texture:t,filters:r}=e;const n=this._pushFilterData();this._activeFilterData=n,n.skip=!1,n.filters=r;const i=t.source,a=i.resolution,o=i.antialias;if(r.every(e=>!e.enabled))return n.skip=!0,t;const s=n.bounds;if(s.addRect(t.frame),this._calculateFilterBounds(n,s.rectangle,o,a,0),n.skip)return t;const u=a;this._calculateGlobalFrame(n,0,0,u,i.width,i.height),n.outputRenderSurface=m.W.getOptimalTexture(s.width,s.height,n.resolution,n.antialias),n.backTexture=f.g.EMPTY,n.inputTexture=t;this.renderer.renderTarget.finishRenderPass(),this._applyFiltersToTexture(n,!0);const l=n.outputRenderSurface;return l.source.alphaMode="premultiplied-alpha",l}pop(){const e=this.renderer,t=this._popFilterData();t.skip||(e.globalUniforms.pop(),e.renderTarget.finishRenderPass(),this._activeFilterData=t,this._applyFiltersToTexture(t,!1),t.blendRequired&&m.W.returnTexture(t.backTexture),m.W.returnTexture(t.inputTexture))}getBackTexture(e,t,r){const n=e.colorTexture.source._resolution,i=m.W.getOptimalTexture(t.width,t.height,n,!1);let a=t.minX,o=t.minY;r&&(a-=r.minX,o-=r.minY),a=Math.floor(a*n),o=Math.floor(o*n);const s=Math.ceil(t.width*n),u=Math.ceil(t.height*n);return this.renderer.renderTarget.copyToTexture(e,i,{x:a,y:o},{width:s,height:u},{x:0,y:0}),i}applyFilter(e,t,r,n){const i=this.renderer,a=this._activeFilterData,o=a.outputRenderSurface===r,s=i.renderTarget.rootRenderTarget.colorTexture.source._resolution,u=this._findFilterResolution(s);let l=0,d=0;if(o){const e=this._findPreviousFilterOffset();l=e.x,d=e.y}this._updateFilterUniforms(t,r,a,l,d,u,o,n);const c=e.enabled?e:this._getPassthroughFilter();this._setupBindGroupsAndRender(c,t,i)}calculateSpriteMatrix(e,t){const r=this._activeFilterData,n=e.set(r.inputTexture._source.width,0,0,r.inputTexture._source.height,r.bounds.minX,r.bounds.minY),i=t.worldTransform.copyTo(d.u.shared),a=t.renderGroup||t.parentRenderGroup;return a&&a.cacheToLocalTransform&&i.prepend(a.cacheToLocalTransform),i.invert(),n.prepend(i),n.scale(1/t.texture.orig.width,1/t.texture.orig.height),n.translate(t.anchor.x,t.anchor.y),n}destroy(){var e;null===(e=this._passthroughFilter)||void 0===e||e.destroy(!0),this._passthroughFilter=null}_getPassthroughFilter(){var e;return null!==(e=this._passthroughFilter)&&void 0!==e||(this._passthroughFilter=new l),this._passthroughFilter}_setupBindGroupsAndRender(e,t,r){if(r.renderPipes.uniformBatch){const e=r.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(e,0)}else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms,0);this._globalFilterBindGroup.setResource(t.source,1),this._globalFilterBindGroup.setResource(t.source.style,2),e.groups[0]=this._globalFilterBindGroup,r.encoder.draw({geometry:b,shader:e,state:e._state,topology:"triangle-list"}),r.type===g.W.WEBGL&&r.renderTarget.finishRenderPass()}_setupFilterTextures(e,t,r,n){if(e.backTexture=f.g.EMPTY,e.inputTexture=m.W.getOptimalTexture(t.width,t.height,e.resolution,e.antialias),e.blendRequired){r.renderTarget.finishRenderPass();const i=r.renderTarget.getRenderTarget(e.outputRenderSurface);e.backTexture=this.getBackTexture(i,t,null===n||void 0===n?void 0:n.bounds)}r.renderTarget.bind(e.inputTexture,!0),r.globalUniforms.push({offset:t})}_calculateGlobalFrame(e,t,r,n,i,a){const o=e.globalFrame;o.x=t*n,o.y=r*n,o.width=i*n,o.height=a*n}_updateFilterUniforms(e,t,r,n,i,a,o,s){const u=this._filterGlobalUniforms.uniforms,l=u.uOutputFrame,d=u.uInputSize,c=u.uInputPixel,h=u.uInputClamp,p=u.uGlobalFrame,m=u.uOutputTexture;o?(l[0]=r.bounds.minX-n,l[1]=r.bounds.minY-i):(l[0]=0,l[1]=0),l[2]=e.frame.width,l[3]=e.frame.height,d[0]=e.source.width,d[1]=e.source.height,d[2]=1/d[0],d[3]=1/d[1],c[0]=e.source.pixelWidth,c[1]=e.source.pixelHeight,c[2]=1/c[0],c[3]=1/c[1],h[0]=.5*c[2],h[1]=.5*c[3],h[2]=e.frame.width*d[2]-.5*c[2],h[3]=e.frame.height*d[3]-.5*c[3];const g=this.renderer.renderTarget.rootRenderTarget.colorTexture;p[0]=n*a,p[1]=i*a,p[2]=g.source.width*a,p[3]=g.source.height*a,t instanceof f.g&&(t.source.resource=null);const x=this.renderer.renderTarget.getRenderTarget(t);this.renderer.renderTarget.bind(t,!!s),t instanceof f.g?(m[0]=t.frame.width,m[1]=t.frame.height):(m[0]=x.width,m[1]=x.height),m[2]=x.isRoot?-1:1,this._filterGlobalUniforms.update()}_findFilterResolution(e){let t=this._filterStackIndex-1;for(;t>0&&this._filterStack[t].skip;)--t;return t>0&&this._filterStack[t].inputTexture?this._filterStack[t].inputTexture.source._resolution:e}_findPreviousFilterOffset(){let e=0,t=0,r=this._filterStackIndex;for(;r>0;){r--;const n=this._filterStack[r];if(!n.skip){e=n.bounds.minX,t=n.bounds.minY;break}}return{x:e,y:t}}_calculateFilterArea(e,t){if(e.renderables?function(e,t){t.clear();const r=t.matrix;for(let i=0;i<e.length;i++){var n;const r=e[i];if(r.globalDisplayStatus<7)continue;const a=null!==(n=r.renderGroup)&&void 0!==n?n:r.parentRenderGroup;null!==a&&void 0!==a&&a.isCachedAsTexture?t.matrix=v.copyFrom(a.textureOffsetInverseTransform).append(r.worldTransform):null!==a&&void 0!==a&&a._parentCacheAsTextureRenderGroup?t.matrix=v.copyFrom(a._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(r.groupTransform):t.matrix=r.worldTransform,t.addBounds(r.bounds)}t.matrix=r}(e.renderables,t):e.filterEffect.filterArea?(t.clear(),t.addRect(e.filterEffect.filterArea),t.applyMatrix(e.container.worldTransform)):e.container.getFastGlobalBounds(!0,t),e.container){const r=(e.container.renderGroup||e.container.parentRenderGroup).cacheToLocalTransform;r&&t.applyMatrix(r)}}_applyFiltersToTexture(e,t){const r=e.inputTexture,n=e.bounds,i=e.filters,a=e.firstEnabledIndex,o=e.lastEnabledIndex;if(this._globalFilterBindGroup.setResource(r.source.style,2),this._globalFilterBindGroup.setResource(e.backTexture.source,3),a===o)i[a].apply(this,r,e.outputRenderSurface,t);else{let r=e.inputTexture;const s=m.W.getOptimalTexture(n.width,n.height,r.source._resolution,!1);let u=s;for(let e=a;e<o;e++){const t=i[e];if(!t.enabled)continue;t.apply(this,r,u,!0);const n=r;r=u,u=n}i[o].apply(this,r,e.outputRenderSurface,t),m.W.returnTexture(s)}}_calculateFilterBounds(e,t,r,n,i){const a=this.renderer,o=e.bounds,s=e.filters;let u=1/0,l=0,d=!0,c=!1,h=!1,p=!0,f=-1,m=-1;for(let v=0;v<s.length;v++){var g,x;const e=s[v];if(!e.enabled)continue;-1===f&&(f=v),m=v,u=Math.min(u,"inherit"===e.resolution?n:e.resolution),l+=e.padding,"off"===e.antialias?d=!1:"inherit"===e.antialias&&d&&(d=r),e.clipToViewport||(p=!1);if(!!!(e.compatibleRenderers&a.type)){h=!1;break}if(e.blendRequired&&null!==(g=null===(x=a.backBuffer)||void 0===x?void 0:x.useBackBuffer)&&void 0!==g&&!g){(0,_.R)("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),h=!1;break}h=!0,c||(c=e.blendRequired)}h?(p&&o.fitBounds(0,t.width/n,0,t.height/n),o.scale(u).ceil().scale(1/u).pad((0|l)*i),o.isPositive?(e.antialias=d,e.resolution=u,e.blendRequired=c,e.firstEnabledIndex=f,e.lastEnabledIndex=m):e.skip=!0):e.skip=!0}_popFilterData(){return this._filterStackIndex--,this._filterStack[this._filterStackIndex]}_getPreviousFilterData(){let e,t=this._filterStackIndex-1;for(;t>0&&(t--,e=this._filterStack[t],e.skip););return e}_pushFilterData(){let e=this._filterStack[this._filterStackIndex];return e||(e=this._filterStack[this._filterStackIndex]=new y),this._filterStackIndex++,e}}T.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem],name:"filter"},n.XO.add(T),n.XO.add(i)},4207(e,t,r){var n=r(1478),i=r(3596),a=r(2590),o=r(5222),s=r(2080),u=r(9385),l=r(475);class d{destroy(){}}class c{constructor(e,t){this.localUniforms=new o.k({uTransformMatrix:{value:new i.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new a.T({0:this.localUniforms}),this.renderer=e,this._adaptor=t,this._adaptor.init()}validateRenderable(e){const t=this._getMeshData(e),r=t.batched,n=e.batched;if(t.batched=n,r!==n)return!0;if(n){const r=e._geometry;if(r.indices.length!==t.indexSize||r.positions.length!==t.vertexSize)return t.indexSize=r.indices.length,t.vertexSize=r.positions.length,!0;const n=this._getBatchableMesh(e);return n.texture.uid!==e._texture.uid&&(n._textureMatrixUpdateId=-1),!n._batcher.checkAndUpdateTexture(n,e._texture)}return!1}addRenderable(e,t){const r=this.renderer.renderPipes.batch,n=this._getMeshData(e);var i,a;e.didViewUpdate&&(n.indexSize=null===(i=e._geometry.indices)||void 0===i?void 0:i.length,n.vertexSize=null===(a=e._geometry.positions)||void 0===a?void 0:a.length);if(n.batched){const n=this._getBatchableMesh(e);n.setTexture(e._texture),n.geometry=e._geometry,r.addToBatch(n,t)}else r.break(t),t.add(e)}updateRenderable(e){if(e.batched){const t=this._getBatchableMesh(e);t.setTexture(e._texture),t.geometry=e._geometry,t._batcher.updateElement(t)}}execute(e){if(!e.isRenderable)return;e.state.blendMode=(0,s.i)(e.groupBlendMode,e.texture._source);const t=this.localUniforms;t.uniforms.uTransformMatrix=e.groupTransform,t.uniforms.uRound=this.renderer._roundPixels|e._roundPixels,t.update(),(0,u.V)(e.groupColorAlpha,t.uniforms.uColor,0),this._adaptor.execute(this,e)}_getMeshData(e){var t,r;return(t=e._gpuData)[r=this.renderer.uid]||(t[r]=new d),e._gpuData[this.renderer.uid].meshData||this._initMeshData(e)}_initMeshData(e){return e._gpuData[this.renderer.uid].meshData={batched:e.batched,indexSize:0,vertexSize:0},e._gpuData[this.renderer.uid].meshData}_getBatchableMesh(e){var t,r;return(t=e._gpuData)[r=this.renderer.uid]||(t[r]=new d),e._gpuData[this.renderer.uid].batchableMesh||this._initBatchableMesh(e)}_initBatchableMesh(e){const t=new l.U;return t.renderable=e,t.setTexture(e._texture),t.transform=e.groupTransform,t.roundPixels=this.renderer._roundPixels|e._roundPixels,e._gpuData[this.renderer.uid].batchableMesh=t,t}destroy(){this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}c.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"mesh"},n.XO.add(c)},4749(e,t,r){r.d(t,{M:()=>a});var n=r(3202);const i=new(r(6373).c);function a(e,t,r,a){const o=i;o.minX=0,o.minY=0,o.maxX=e.width/a|0,o.maxY=e.height/a|0;const s=n.W.getOptimalTexture(o.width,o.height,a,!1);return s.source.uploadMethodId="image",s.source.resource=e,s.source.alphaMode="premultiply-alpha-on-upload",s.frame.width=t/a,s.frame.height=r/a,s.source.emit("update",s.source),s.updateUvs(),s}},4821(e,t,r){var n=r(1478),i=r(4745),a=r(475),o=r(2555),s=r(4811),u=r(9859);const l=class e extends u.u{constructor(){var e;super({});let t=null!==(e=arguments.length<=0?void 0:arguments[0])&&void 0!==e?e:{};"number"===typeof t&&((0,s.t6)(s.lj,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),t={width:t,height:arguments.length<=1?void 0:arguments[1],verticesX:arguments.length<=2?void 0:arguments[2],verticesY:arguments.length<=3?void 0:arguments[3]}),this.build(t)}build(t){var r,n,i,a;t=(0,o.A)((0,o.A)({},e.defaultOptions),t),this.verticesX=null!==(r=this.verticesX)&&void 0!==r?r:t.verticesX,this.verticesY=null!==(n=this.verticesY)&&void 0!==n?n:t.verticesY,this.width=null!==(i=this.width)&&void 0!==i?i:t.width,this.height=null!==(a=this.height)&&void 0!==a?a:t.height;const s=this.verticesX*this.verticesY,u=[],l=[],d=[],c=this.verticesX-1,h=this.verticesY-1,p=this.width/c,f=this.height/h;for(let e=0;e<s;e++){const t=e%this.verticesX,r=e/this.verticesX|0;u.push(t*p,r*f),l.push(t/c,r/h)}const m=c*h;for(let e=0;e<m;e++){const t=e%c,r=e/c|0,n=r*this.verticesX+t,i=r*this.verticesX+t+1,a=(r+1)*this.verticesX+t,o=(r+1)*this.verticesX+t+1;d.push(n,i,a,i,o,a)}this.buffers[0].data=new Float32Array(u),this.buffers[1].data=new Float32Array(l),this.indexBuffer.data=new Uint32Array(d),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};l.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let d=l;const c=class e extends d{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};t=(0,o.A)((0,o.A)({},e.defaultOptions),t),super({width:t.width,height:t.height,verticesX:4,verticesY:4}),this.update(t)}update(e){var t,r,n,i,a,o,s,u,l,d;this.width=null!==(t=e.width)&&void 0!==t?t:this.width,this.height=null!==(r=e.height)&&void 0!==r?r:this.height,this._originalWidth=null!==(n=e.originalWidth)&&void 0!==n?n:this._originalWidth,this._originalHeight=null!==(i=e.originalHeight)&&void 0!==i?i:this._originalHeight,this._leftWidth=null!==(a=e.leftWidth)&&void 0!==a?a:this._leftWidth,this._rightWidth=null!==(o=e.rightWidth)&&void 0!==o?o:this._rightWidth,this._topHeight=null!==(s=e.topHeight)&&void 0!==s?s:this._topHeight,this._bottomHeight=null!==(u=e.bottomHeight)&&void 0!==u?u:this._bottomHeight,this._anchorX=null===(l=e.anchor)||void 0===l?void 0:l.x,this._anchorY=null===(d=e.anchor)||void 0===d?void 0:d.y,this.updateUvs(),this.updatePositions()}updatePositions(){const e=this.positions,{width:t,height:r,_leftWidth:n,_rightWidth:i,_topHeight:a,_bottomHeight:o,_anchorX:s,_anchorY:u}=this,l=n+i,d=t>l?1:t/l,c=a+o,h=r>c?1:r/c,p=Math.min(d,h),f=s*t,m=u*r;e[0]=e[8]=e[16]=e[24]=-f,e[2]=e[10]=e[18]=e[26]=n*p-f,e[4]=e[12]=e[20]=e[28]=t-i*p-f,e[6]=e[14]=e[22]=e[30]=t-f,e[1]=e[3]=e[5]=e[7]=-m,e[9]=e[11]=e[13]=e[15]=a*p-m,e[17]=e[19]=e[21]=e[23]=r-o*p-m,e[25]=e[27]=e[29]=e[31]=r-m,this.getBuffer("aPosition").update()}updateUvs(){const e=this.uvs;e[0]=e[8]=e[16]=e[24]=0,e[1]=e[3]=e[5]=e[7]=0,e[6]=e[14]=e[22]=e[30]=1,e[25]=e[27]=e[29]=e[31]=1;const t=1/this._originalWidth,r=1/this._originalHeight;e[2]=e[10]=e[18]=e[26]=t*this._leftWidth,e[9]=e[11]=e[13]=e[15]=r*this._topHeight,e[4]=e[12]=e[20]=e[28]=1-t*this._rightWidth,e[17]=e[19]=e[21]=e[23]=1-r*this._bottomHeight,this.getBuffer("aUV").update()}};c.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let h=c;class p extends a.U{constructor(){super(),this.geometry=new h}destroy(){this.geometry.destroy()}}class f{constructor(e){this._renderer=e,this._managedSprites=new i.s({renderer:e,type:"renderable",name:"nineSliceSprite"})}addRenderable(e,t){const r=this._getGpuSprite(e);e.didViewUpdate&&this._updateBatchableSprite(e,r),this._renderer.renderPipes.batch.addToBatch(r,t)}updateRenderable(e){const t=this._getGpuSprite(e);e.didViewUpdate&&this._updateBatchableSprite(e,t),t._batcher.updateElement(t)}validateRenderable(e){const t=this._getGpuSprite(e);return!t._batcher.checkAndUpdateTexture(t,e._texture)}_updateBatchableSprite(e,t){t.geometry.update(e),t.setTexture(e._texture)}_getGpuSprite(e){return e._gpuData[this._renderer.uid]||this._initGPUSprite(e)}_initGPUSprite(e){const t=e._gpuData[this._renderer.uid]=new p,r=t;return r.renderable=e,r.transform=e.groupTransform,r.texture=e._texture,r.roundPixels=this._renderer._roundPixels|e._roundPixels,this._managedSprites.add(e),e.didViewUpdate||this._updateBatchableSprite(e,r),t}destroy(){this._managedSprites.destroy(),this._renderer=null}}f.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"nineSliceSprite"},n.XO.add(f)},5231(e,t,r){var n=r(1478);class i{execute(e,t){const r=e.state,n=e.renderer,i=t.shader||e.defaultShader;i.resources.uTexture=t.texture._source,i.resources.uniforms=e.localUniforms;const a=n.gl,o=e.getBuffers(t);n.shader.bind(i),n.state.set(r),n.geometry.bind(o.geometry,i.glProgram);const s=2===o.geometry.indexBuffer.data.BYTES_PER_ELEMENT?a.UNSIGNED_SHORT:a.UNSIGNED_INT;a.drawElements(a.TRIANGLES,6*t.particleChildren.length,s,0)}}var a=r(3596),o=r(5222),s=r(2080),u=r(576),l=r(4745),d=r(9385),c=r(5202),h=r(6333),p=r(9801),f=r(7393),m=r(1013);function g(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=6*e;if(r>65535?t||(t=new Uint32Array(r)):t||(t=new Uint16Array(r)),t.length!==r)throw new Error("Out buffer length is incorrect, got ".concat(t.length," and expected ").concat(r));for(let n=0,i=0;n<r;n+=6,i+=4)t[n+0]=i+0,t[n+1]=i+1,t[n+2]=i+2,t[n+3]=i+0,t[n+4]=i+2,t[n+5]=i+3;return t}function x(e,t){const r=[];r.push("\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            ");let n=0;for(const a in e){const i=e[a];if(t!==i.dynamic)continue;r.push("offset = index + ".concat(n)),r.push(i.code);n+=(0,f.m)(i.format).stride/4}r.push("\n            index += stride * 4;\n        }\n    "),r.unshift("\n        var stride = ".concat(n,";\n    "));const i=r.join("\n");return new Function("ps","f32v","u32v",i)}class v{constructor(e){var t;this._size=0,this._generateParticleUpdateCache={};const r=this._size=null!==(t=e.size)&&void 0!==t?t:1e3,n=e.properties;let i=0,a=0;for(const d in n){const e=n[d],t=(0,f.m)(e.format);e.dynamic?a+=t.stride:i+=t.stride}this._dynamicStride=a/4,this._staticStride=i/4,this.staticAttributeBuffer=new m.u(4*r*i),this.dynamicAttributeBuffer=new m.u(4*r*a),this.indexBuffer=g(r);const o=new p.V;let s=0,u=0;this._staticBuffer=new c.h({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:h.S.VERTEX|h.S.COPY_DST}),this._dynamicBuffer=new c.h({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:h.S.VERTEX|h.S.COPY_DST});for(const d in n){const e=n[d],t=(0,f.m)(e.format);e.dynamic?(o.addAttribute(e.attributeName,{buffer:this._dynamicBuffer,stride:4*this._dynamicStride,offset:4*s,format:e.format}),s+=t.size):(o.addAttribute(e.attributeName,{buffer:this._staticBuffer,stride:4*this._staticStride,offset:4*u,format:e.format}),u+=t.size)}o.addIndex(this.indexBuffer);const l=this.getParticleUpdate(n);this._dynamicUpload=l.dynamicUpdate,this._staticUpload=l.staticUpdate,this.geometry=o}getParticleUpdate(e){const t=function(e){const t=[];for(const r in e){const n=e[r];t.push(r,n.code,n.dynamic?"d":"s")}return t.join("_")}(e);return this._generateParticleUpdateCache[t]||(this._generateParticleUpdateCache[t]=this.generateParticleUpdate(e)),this._generateParticleUpdateCache[t]}generateParticleUpdate(e){return function(e){return{dynamicUpdate:x(e,!0),staticUpdate:x(e,!1)}}(e)}update(e,t){e.length>this._size&&(t=!0,this._size=Math.max(e.length,1.5*this._size|0),this.staticAttributeBuffer=new m.u(this._size*this._staticStride*4*4),this.dynamicAttributeBuffer=new m.u(this._size*this._dynamicStride*4*4),this.indexBuffer=g(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const r=this.dynamicAttributeBuffer;if(this._dynamicUpload(e,r.float32View,r.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,e.length*this._dynamicStride*4,!0),t){const t=this.staticAttributeBuffer;this._staticUpload(e,t.float32View,t.uint32View),this._staticBuffer.setDataWithSize(t.float32View,e.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}var _=r(5242),b=r(5920),y=r(7699),T=r(3636),w=r(5705),C=r(879),S="\nstruct ParticleUniforms {\n  uTranslationMatrix:mat3x3<f32>,\n  uColor:vec4<f32>,\n  uRound:f32,\n  uResolution:vec2<f32>,\n};\n\nfn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n{\n  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d<f32>;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) color : vec4<f32>,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2<f32>,\n  @location(1) aPosition: vec2<f32>,\n  @location(2) aUV: vec2<f32>,\n  @location(3) aColor: vec4<f32>,\n  @location(4) aRotation: f32,\n) -> VSOutput {\n  \n   let v = vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n   if(uniforms.uRound == 1.0) {\n       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);\n   }\n\n    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) color: vec4<f32>,\n  @builtin(position) position: vec4<f32>,\n) -> @location(0) vec4<f32> {\n\n    var sample = textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";class P extends T.M{constructor(){super({glProgram:b.M.from({vertex:"attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation = cos(aRotation);\n    float sinRotation = sin(aRotation);\n    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v = vec2(x, y);\n    v = v + aPosition;\n\n    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound == 1.0)\n    {\n        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV = aUV;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n",fragment:"varying vec2 vUV;\nvarying vec4 vColor;\n\nuniform sampler2D uTexture;\n\nvoid main(void){\n    vec4 color = texture2D(uTexture, vUV) * vColor;\n    gl_FragColor = color;\n}"}),gpuProgram:y.B.from({fragment:{source:S,entryPoint:"mainFragment"},vertex:{source:S,entryPoint:"mainVertex"}}),resources:{uTexture:w.g.WHITE.source,uSampler:new C.n({}),uniforms:{uTranslationMatrix:{value:new a.u,type:"mat3x3<f32>"},uColor:{value:new _.Q(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class U{constructor(e,t){this.state=u.U.for2d(),this.localUniforms=new o.k({uTranslationMatrix:{value:new a.u,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=e,this.adaptor=t,this.defaultShader=new P,this.state=u.U.for2d(),this._managedContainers=new l.s({renderer:e,type:"renderable",name:"particleContainer"})}validateRenderable(e){return!1}addRenderable(e,t){this.renderer.renderPipes.batch.break(t),t.add(e)}getBuffers(e){return e._gpuData[this.renderer.uid]||this._initBuffer(e)}_initBuffer(e){return e._gpuData[this.renderer.uid]=new v({size:e.particleChildren.length,properties:e._properties}),this._managedContainers.add(e),e._gpuData[this.renderer.uid]}updateRenderable(e){}execute(e){const t=e.particleChildren;if(0===t.length)return;const r=this.renderer,n=this.getBuffers(e);e.texture||(e.texture=t[0].texture);const i=this.state;n.update(t,e._childrenDirty),e._childrenDirty=!1,i.blendMode=(0,s.i)(e.blendMode,e.texture._source);const a=this.localUniforms.uniforms,o=a.uTranslationMatrix;e.worldTransform.copyTo(o),o.prepend(r.globalUniforms.globalUniformData.projectionMatrix),a.uResolution=r.globalUniforms.globalUniformData.resolution,a.uRound=r._roundPixels|e._roundPixels,(0,d.V)(e.groupColorAlpha,a.uColor,0),this.adaptor.execute(this,e)}destroy(){this._managedContainers.destroy(),this.renderer=null,this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class R extends U{constructor(e){super(e,new i)}}R.extension={type:[n.Ag.WebGLPipes],name:"particle"};class F{execute(e,t){const r=e.renderer,n=t.shader||e.defaultShader;n.groups[0]=r.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms,!0),n.groups[1]=r.texture.getTextureBindGroup(t.texture);const i=e.state,a=e.getBuffers(t);r.encoder.draw({geometry:a.geometry,shader:t.shader||e.defaultShader,state:i,size:6*t.particleChildren.length})}}class M extends U{constructor(e){super(e,new F)}}M.extension={type:[n.Ag.WebGPUPipes],name:"particle"},n.XO.add(R),n.XO.add(M)},5608(e,t,r){var n=r(1478),i=r(5705),a=r(4745),o=r(6595),s=r(1669);class u extends s.K{constructor(){super(...arguments),this.generatingTexture=!1,this.currentKey="--"}destroy(){this.texturePromise=null,this.generatingTexture=!1,this.currentKey="--",super.destroy()}}class l{constructor(e){this._renderer=e,e.runners.resolutionChange.add(this),this._managedTexts=new a.s({renderer:e,type:"renderable",onUnload:this.onTextUnload.bind(this),name:"htmlText"})}resolutionChange(){for(const e in this._managedTexts.items){const t=this._managedTexts.items[e];null!==t&&void 0!==t&&t._autoResolution&&t.onViewUpdate()}}validateRenderable(e){const t=this._getGpuText(e),r=e.styleKey;return t.currentKey!==r}addRenderable(e,t){const r=this._getGpuText(e);if(e._didTextUpdate){const t=e._autoResolution?this._renderer.resolution:e.resolution;r.currentKey===e.styleKey&&e.resolution===t||this._updateGpuText(e).catch(e=>{console.error(e)}),e._didTextUpdate=!1,(0,o.s)(r,e)}this._renderer.renderPipes.batch.addToBatch(r,t)}updateRenderable(e){const t=this._getGpuText(e);t._batcher.updateElement(t)}async _updateGpuText(e){e._didTextUpdate=!1;const t=this._getGpuText(e);if(t.generatingTexture)return;const r=t.texturePromise;t.texturePromise=null,t.generatingTexture=!0,e._resolution=e._autoResolution?this._renderer.resolution:e.resolution;let n=this._renderer.htmlText.getTexturePromise(e);r&&(n=n.finally(()=>{this._renderer.htmlText.decreaseReferenceCount(t.currentKey),this._renderer.htmlText.returnTexturePromise(r)})),t.texturePromise=n,t.currentKey=e.styleKey,t.texture=await n;const i=e.renderGroup||e.parentRenderGroup;i&&(i.structureDidChange=!0),t.generatingTexture=!1,(0,o.s)(t,e)}_getGpuText(e){return e._gpuData[this._renderer.uid]||this.initGpuText(e)}initGpuText(e){const t=new u;return t.renderable=e,t.transform=e.groupTransform,t.texture=i.g.EMPTY,t.bounds={minX:0,maxX:1,minY:0,maxY:0},t.roundPixels=this._renderer._roundPixels|e._roundPixels,e._resolution=e._autoResolution?this._renderer.resolution:e.resolution,e._gpuData[this._renderer.uid]=t,this._managedTexts.add(e),t}onTextUnload(e){const t=e._gpuData[this._renderer.uid];if(!t)return;const{htmlText:r}=this._renderer;null===r.getReferenceCount(t.currentKey)?r.returnTexturePromise(t.texturePromise):r.decreaseReferenceCount(t.currentKey)}destroy(){this._managedTexts.destroy(),this._renderer=null}}l.extension={type:[n.Ag.WebGLPipes,n.Ag.WebGPUPipes,n.Ag.CanvasPipes],name:"htmlText"};var d=r(9445),c=r(3202),h=r(6650),p=r(3144);var f=r(279),m=r(2521),g=r(4749);const x="http://www.w3.org/2000/svg",v="http://www.w3.org/1999/xhtml";class _{constructor(){this.svgRoot=document.createElementNS(x,"svg"),this.foreignObject=document.createElementNS(x,"foreignObject"),this.domElement=document.createElementNS(v,"div"),this.styleElement=document.createElementNS(v,"style");const{foreignObject:e,svgRoot:t,styleElement:r,domElement:n}=this;e.setAttribute("width","10000"),e.setAttribute("height","10000"),e.style.overflow="hidden",t.appendChild(e),e.appendChild(r),e.appendChild(n),this.image=p.e.get().createImage()}destroy(){this.svgRoot.remove(),this.foreignObject.remove(),this.styleElement.remove(),this.domElement.remove(),this.image.src="",this.image.remove(),this.svgRoot=null,this.foreignObject=null,this.styleElement=null,this.domElement=null,this.image=null,this.canvasAndContext=null}}var b=r(8656);async function y(e,t){const r=await async function(e){const t=await p.e.get().fetch(e),r=await t.blob(),n=new FileReader;return await new Promise((e,t)=>{n.onloadend=()=>e(n.result),n.onerror=t,n.readAsDataURL(r)})}(t);return'@font-face {\n        font-family: "'.concat(e.fontFamily,'";\n        font-weight: ').concat(e.fontWeight,";\n        font-style: ").concat(e.fontStyle,";\n        src: url('").concat(r,"');\n    }")}const T=new Map;let w;class C{constructor(e){this._activeTextures={},this._renderer=e,this._createCanvas=e.type===h.W.WEBGPU}getTexture(e){return this.getTexturePromise(e)}getManagedTexture(e){const t=e.styleKey;if(this._activeTextures[t])return this._increaseReferenceCount(t),this._activeTextures[t].promise;const r=this._buildTexturePromise(e).then(e=>(this._activeTextures[t].texture=e,e));return this._activeTextures[t]={texture:null,promise:r,usageCount:1},r}getReferenceCount(e){var t,r;return null!==(t=null===(r=this._activeTextures[e])||void 0===r?void 0:r.usageCount)&&void 0!==t?t:null}_increaseReferenceCount(e){this._activeTextures[e].usageCount++}decreaseReferenceCount(e){const t=this._activeTextures[e];t&&(t.usageCount--,0===t.usageCount&&(t.texture?this._cleanUp(t.texture):t.promise.then(e=>{t.texture=e,this._cleanUp(t.texture)}).catch(()=>{(0,f.R)("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[e]=null))}getTexturePromise(e){return this._buildTexturePromise(e)}async _buildTexturePromise(e){const{text:t,style:r,resolution:n,textureStyle:i}=e,a=m.Z.get(_),o=function(e,t){const r=t.fontFamily,n=[],i={},a=e.match(/font-family:([^;"\s]+)/g);function o(e){i[e]||(n.push(e),i[e]=!0)}if(Array.isArray(r))for(let s=0;s<r.length;s++)o(r[s]);else o(r);a&&a.forEach(e=>{o(e.split(":")[1].trim())});for(const s in t.tagStyles)o(t.tagStyles[s].fontFamily);return n}(t,r),s=await async function(e){const t=e.filter(e=>b.l.has("".concat(e,"-and-url"))).map(e=>{if(!T.has(e)){const{entries:t}=b.l.get("".concat(e,"-and-url")),r=[];t.forEach(t=>{const n=t.url,i=t.faces.map(e=>({weight:e.weight,style:e.style}));r.push(...i.map(t=>y({fontWeight:t.weight,fontStyle:t.style,fontFamily:e},n)))}),T.set(e,Promise.all(r).then(e=>e.join("\n")))}return T.get(e)});return(await Promise.all(t)).join("\n")}(o),u=function(e,t,r,n){n||(n=w||(w=new _));const{domElement:i,styleElement:a,svgRoot:o}=n;i.innerHTML="<style>".concat(t.cssStyle,";</style><div style='padding:0'>").concat(e,"</div>"),i.setAttribute("style","transform-origin: top left; display: inline-block"),r&&(a.textContent=r),document.body.appendChild(o);const s=i.getBoundingClientRect();o.remove();const u=2*t.padding;return{width:s.width-u,height:s.height-u}}(t,r,s,a),l=Math.ceil(Math.ceil(Math.max(1,u.width)+2*r.padding)*n),c=Math.ceil(Math.ceil(Math.max(1,u.height)+2*r.padding)*n),h=a.image;h.width=2+(0|l),h.height=2+(0|c);const f=function(e,t,r,n,i){const{domElement:a,styleElement:o,svgRoot:s}=i;a.innerHTML="<style>".concat(t.cssStyle,"</style><div style='padding:0;'>").concat(e,"</div>"),a.setAttribute("style","transform: scale(".concat(r,");transform-origin: top left; display: inline-block")),o.textContent=n;const{width:u,height:l}=i.image;return s.setAttribute("width",u.toString()),s.setAttribute("height",l.toString()),(new XMLSerializer).serializeToString(s)}(t,r,n,s,a);await function(e,t,r){return new Promise(async n=>{r&&await new Promise(e=>setTimeout(e,100)),e.onload=()=>{n()},e.src="data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(t)),e.crossOrigin="anonymous"})}(h,f,function(){const{userAgent:e}=p.e.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(e)}()&&o.length>0);const x=h;let v;this._createCanvas&&(v=function(e,t){const r=d.N.getOptimalCanvasAndContext(e.width,e.height,t),{context:n}=r;return n.clearRect(0,0,e.width,e.height),n.drawImage(e,0,0),r}(h,n));const C=(0,g.M)(v?v.canvas:x,h.width-2,h.height-2,n);return i&&(C.source.style=i),this._createCanvas&&(this._renderer.texture.initSource(C.source),d.N.returnCanvasAndContext(v)),m.Z.return(a),C}returnTexturePromise(e){e.then(e=>{this._cleanUp(e)}).catch(()=>{(0,f.R)("HTMLTextSystem: Failed to clean texture")})}_cleanUp(e){c.W.returnTexture(e,!0),e.source.resource=null,e.source.uploadMethodId="unknown"}destroy(){this._renderer=null;for(const e in this._activeTextures)this._activeTextures[e]&&this.returnTexturePromise(this._activeTextures[e].promise);this._activeTextures=null}}C.extension={type:[n.Ag.WebGLSystem,n.Ag.WebGPUSystem,n.Ag.CanvasSystem],name:"htmlText"},n.XO.add(C),n.XO.add(l)},6595(e,t,r){r.d(t,{s:()=>i});var n=r(3693);function i(e,t){const{texture:r,bounds:i}=e,a=t._style._getFinalPadding();(0,n.y)(i,t._anchor,r);const o=t._anchor._x*a*2,s=t._anchor._y*a*2;i.minX-=a-o,i.minY-=a-s,i.maxX-=a-o,i.maxY-=a-s}},8957(e,t,r){var n=r(1478),i=r(8898),a=r(3828);n.XO.add(i.U),n.XO.add(a.y)},9385(e,t,r){function n(e,t,r){const n=(e>>24&255)/255;t[r++]=(255&e)/255*n,t[r++]=(e>>8&255)/255*n,t[r++]=(e>>16&255)/255*n,t[r++]=n}r.d(t,{V:()=>n})},9859(e,t,r){r.d(t,{u:()=>l});var n=r(2555),i=r(5202),a=r(6333),o=r(9801),s=r(4811);const u=class e extends o.V{constructor(){var t;let r=null!==(t=arguments.length<=0?void 0:arguments[0])&&void 0!==t?t:{};r instanceof Float32Array&&((0,s.t6)(s.lj,"use new MeshGeometry({ positions, uvs, indices }) instead"),r={positions:r,uvs:arguments.length<=1?void 0:arguments[1],indices:arguments.length<=2?void 0:arguments[2]}),r=(0,n.A)((0,n.A)({},e.defaultOptions),r);const o=r.positions||new Float32Array([0,0,1,0,1,1,0,1]);let u=r.uvs;u||(u=r.positions?new Float32Array(o.length):new Float32Array([0,0,1,0,1,1,0,1]));const l=r.indices||new Uint32Array([0,1,2,0,2,3]),d=r.shrinkBuffersToFit;super({attributes:{aPosition:{buffer:new i.h({data:o,label:"attribute-mesh-positions",shrinkToFit:d,usage:a.S.VERTEX|a.S.COPY_DST}),format:"float32x2",stride:8,offset:0},aUV:{buffer:new i.h({data:u,label:"attribute-mesh-uvs",shrinkToFit:d,usage:a.S.VERTEX|a.S.COPY_DST}),format:"float32x2",stride:8,offset:0}},indexBuffer:new i.h({data:l,label:"index-mesh-buffer",shrinkToFit:d,usage:a.S.INDEX|a.S.COPY_DST}),topology:r.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(e){this.attributes.aPosition.buffer.data=e}get uvs(){return this.attributes.aUV.buffer.data}set uvs(e){this.attributes.aUV.buffer.data=e}get indices(){return this.indexBuffer.data}set indices(e){this.indexBuffer.data=e}};u.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let l=u}}]);
//# sourceMappingURL=838.75dee7d7.chunk.js.map