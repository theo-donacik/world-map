{"version":3,"file":"static/js/480.a0734909.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts","../node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts","../node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts","../node_modules/pixi.js/src/scene/container/utils/clearList.ts","../node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts","../node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts","../node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts","../node_modules/pixi.js/src/scene/sprite/SpritePipe.ts","../node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts","../node_modules/pixi.js/src/filters/mask/MaskFilter.ts","../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts","../node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts","../node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts","../node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts","../node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts","../node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/GCSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts","../node_modules/pixi.js/src/utils/sayHello.ts","../node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts","../node_modules/pixi.js/src/utils/data/clean.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts","../node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts","../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts","../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts","../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts","../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts","../node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts"],"sourcesContent":["// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @category rendering\n * @advanced\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @category rendering\n * @advanced\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n","/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","import { type GPUData } from '../view/ViewContainer';\n\nimport type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement, GPUData\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        this.reset();\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @category rendering\n * @internal\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderer\n * @internal\n */\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The RenderGroupPipe is a render pipe for rendering RenderGroups.\n * @internal\n */\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n\n        this._renderer.renderPipes.blendMode.pushBlendMode(renderGroup, renderGroup.root.groupBlendMode, instructionSet);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n        this._renderer.renderPipes.blendMode.popBlendMode(instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n                offset: { x: 0, y: 0 },\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n","/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n * @category utils\n * @internal\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n","import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\n/**\n * @param renderGroup\n * @param updateChildRenderGroups\n * @internal\n */\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\n/**\n * @param renderGroup\n * @internal\n */\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\n/**\n * @param container\n * @param updateTick\n * @param updateFlags\n * @internal\n */\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @internal\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        const originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            // Early out as nothing further needs to be updated!\n            if (!renderGroup.textureNeedsUpdate) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        // Update the closest cache reference for children if this render group is cached as texture\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture, true);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n                const scaleMode = renderGroup.textureOptions.scaleMode ?? 'linear';\n                const texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                texture._source.style = new TextureStyle({ scaleMode });\n                renderGroup.texture = texture;\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture, true);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n","import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\n/**\n * @param renderGroup\n * @param renderPipes\n * @internal\n */\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < renderGroup.childrenRenderablesToUpdate.index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Sprite } from './Sprite';\n\n/** @internal */\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = new BatchableSprite();\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        sprite._gpuData[this._renderer.uid] = batchableSprite;\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n","import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\n/** @internal */\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @category rendering\n * @advanced\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher({\n                maxTextures: this.renderer.limits.maxBatchableTextures,\n            });\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n","import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\n/** @internal */\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\n/** @internal */\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            clipToViewport: false,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\n/** @internal */\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\n/** @internal */\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\n/** @internal */\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\n/** @internal */\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            maskContainer.collectRenderables(\n                instructionSet,\n                renderer,\n                null\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\n/** @internal */\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\n/** @internal */\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorStack = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\n/** @internal */\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\n/** @internal */\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\n/** @internal */\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        maskContainer.collectRenderables(\n            instructionSet,\n            renderer,\n            null\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n","import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n/**\n * Options for the background system.\n * @category rendering\n * @advanced\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /** Alias for `backgroundColor` */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * This value determines whether the canvas is initialized with alpha transparency support.\n     * Note: This cannot be changed after initialization. If set to `1`, the canvas will remain opaque,\n     * even if a transparent background color is set later.\n     * @default 1\n     */\n    backgroundAlpha?: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @default true\n     */\n    clearBeforeRender?: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @category rendering\n * @advanced\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        // #if _DEBUG\n\n        const incoming = Color.shared.setValue(value);\n\n        if (incoming.alpha < 1 && this._backgroundColor.alpha === 1)\n        {\n            warn(\n                'Cannot set a transparent background on an opaque canvas. '\n                + 'To enable transparency, set backgroundAlpha < 1 when initializing your Application.'\n            );\n        }\n        // #endif\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @category rendering\n * @internal\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList?: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n    private readonly _blendModeStack: BLEND_MODES[] = [];\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.prerender.add(this);\n    }\n\n    public prerender()\n    {\n        // make sure we reset the blend modes to normal\n        // this way the next render will register any changes\n        this._activeBlendMode = 'normal';\n        this._isAdvanced = false;\n    }\n\n    /**\n     * Push a blend mode onto the internal stack and apply it to the instruction set if needed.\n     * @param renderable - The renderable or {@link RenderGroup} associated with the change.\n     * @param blendMode - The blend mode to activate.\n     * @param instructionSet - The instruction set being built.\n     */\n    public pushBlendMode(renderable: Renderable | RenderGroup, blendMode: BLEND_MODES, instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.push(blendMode);\n\n        this.setBlendMode(renderable, blendMode, instructionSet);\n    }\n\n    /**\n     * Pop the last blend mode from the stack and apply the new top-of-stack mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public popBlendMode(instructionSet: InstructionSet): void\n    {\n        this._blendModeStack.pop();\n        const blendMode = this._blendModeStack[this._activeBlendMode.length - 1] ?? 'normal';\n\n        this.setBlendMode(null, blendMode, instructionSet);\n    }\n\n    /**\n     * Ensure a blend mode switch is added to the instruction set when the mode changes.\n     * If an advanced blend mode is active, subsequent renderables will be collected so they can be\n     * rendered within a single filter pass.\n     * @param renderable - The renderable or {@link RenderGroup} to associate with the change, or null when unwinding.\n     * @param blendMode - The target blend mode.\n     * @param instructionSet - The instruction set being built.\n     */\n    public setBlendMode(\n        renderable: Renderable | RenderGroup | null,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet\n    )\n    {\n        const isRenderGroup = renderable instanceof RenderGroup;\n\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced && renderable && !isRenderGroup)\n            {\n                this._renderableList?.push(renderable);\n            }\n\n            return;\n        }\n\n        if (this._isAdvanced) this._endAdvancedBlendMode(instructionSet);\n\n        this._activeBlendMode = blendMode;\n\n        if (!renderable) return;\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced) this._beginAdvancedBlendMode(renderable, instructionSet);\n    }\n\n    private _beginAdvancedBlendMode(renderable: Renderable | RenderGroup, instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n                + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        const filterEffect = this._ensureFilterEffect(blendMode);\n        const isRenderGroup = renderable instanceof RenderGroup;\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            filterEffect,\n            renderables: isRenderGroup ? null : [renderable],\n            container: isRenderGroup ? renderable.root : null,\n            canBundle: false\n        };\n\n        this._renderableList = instruction.renderables;\n\n        instructionSet.add(instruction);\n    }\n\n    private _ensureFilterEffect(blendMode: BLEND_MODES): FilterEffect\n    {\n        let filterEffect: FilterEffect = this._filterHash[blendMode];\n\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        return filterEffect;\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._isAdvanced = false;\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (!this._isAdvanced) return;\n\n        this._endAdvancedBlendMode(instructionSet);\n    }\n\n    /** @internal */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { type ImageLike } from '../../../../environment/ImageLike';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * Controls the output format and quality of extracted images.\n * @example\n * ```ts\n * // Extract as PNG (default)\n * const pngImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // Extract as JPEG with quality setting\n * const jpgImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'jpg',\n *     quality: 0.8\n * });\n *\n * // Extract as WebP for better compression\n * const webpImage = await renderer.extract.image({\n *     target: sprite,\n *     format: 'webp',\n *     quality: 0.9\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface ImageOptions\n{\n    /**\n     * The format of the extracted image.\n     * - 'png': Lossless format, best for images with text or sharp edges\n     * - 'jpg': Lossy format, smaller file size, good for photos\n     * - 'webp': Modern format with better compression\n     * @example\n     * ```ts\n     * // Extract as PNG\n     * const pngImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'png'\n     * });\n     * // Extract as JPEG\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     * });\n     * ```\n     * @default 'png'\n     */\n    format?: Formats;\n\n    /**\n     * The quality of the extracted image, between 0 and 1.\n     * Only applies to lossy formats (jpg, webp).\n     * - 1: Maximum quality\n     * - 0: Maximum compression\n     * @example\n     * ```ts\n     * // Extract as JPEG with 80% quality\n     * const jpgImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'jpg',\n     *     quality: 0.8\n     * });\n     * // Extract as WebP with 90% quality\n     * const webpImage = await renderer.extract.image({\n     *     target: sprite,\n     *     format: 'webp',\n     *     quality: 0.9\n     * });\n     * ```\n     * @default 1\n     */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * These options control how content is extracted and processed from the renderer.\n * @example\n * ```ts\n * // Basic extraction\n * const pixels = renderer.extract.pixels({\n *     target: sprite,\n * });\n *\n * // Extract with custom region and resolution\n * const canvas = renderer.extract.canvas({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n * });\n *\n * // Extract with background color and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport interface BaseExtractOptions\n{\n    /**\n     * The target to extract. Can be a Container or Texture.\n     * @example\n     * ```ts\n     * // Extract from a sprite\n     * const sprite = new Sprite(texture);\n     * renderer.extract.pixels({ target: sprite });\n     *\n     * // Extract from a texture directly\n     * renderer.extract.pixels({ target: texture });\n     * ```\n     */\n    target: Container | Texture;\n\n    /**\n     * The region of the target to extract. If not specified, extracts the entire target.\n     * @example\n     * ```ts\n     * // Extract a specific region\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the extracted content. Higher values create sharper images.\n     * @default 1\n     * @example\n     * ```ts\n     * // Extract at 2x resolution for retina displays\n     * renderer.extract.image({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the extracted content before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * renderer.extract.canvas({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing during extraction.\n     * Improves quality but may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Enable anti-aliasing for smoother edges\n     * renderer.extract.image({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * Combines base extraction options with image-specific settings.\n * @example\n * ```ts\n * // Basic PNG extraction\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png'\n * });\n *\n * // High-quality JPEG with custom region\n * const image = await renderer.extract.image({\n *     target: container,\n *     format: 'jpg',\n *     quality: 0.9,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // WebP with background and anti-aliasing\n * const image = await renderer.extract.image({\n *     target: graphics,\n *     format: 'webp',\n *     quality: 0.8,\n *     clearColor: '#ff0000',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - {@link ImageOptions} for image format and quality settings\n *\n * Common use cases:\n * - Capturing game screenshots\n * - Saving rendered content\n * - Creating image thumbnails\n * - Exporting canvas content\n * @see {@link ExtractSystem.image} For the method that uses these options\n * @see {@link ExtractSystem.base64} For base64 encoding\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * Combines base extraction options with download-specific settings.\n * @example\n * ```ts\n * // Basic download with default filename\n * renderer.extract.download({\n *     target: sprite\n * });\n *\n * // Download with custom filename and region\n * renderer.extract.download({\n *     target: container,\n *     filename: 'screenshot.png',\n *     frame: new Rectangle(0, 0, 100, 100)\n * });\n *\n * // Download with high resolution and background\n * renderer.extract.download({\n *     target: stage,\n *     filename: 'hd-capture.png',\n *     resolution: 2,\n *     clearColor: '#ff0000'\n * });\n *\n * // Download with anti-aliasing\n * renderer.extract.download({\n *     target: graphics,\n *     filename: 'smooth.png',\n *     antialias: true\n * });\n * ```\n *\n * Combines all options from:\n * - {@link BaseExtractOptions} for basic extraction settings\n * - Additional download-specific options\n *\n * Common use cases:\n * - Saving game screenshots\n * - Exporting rendered content\n * - Creating downloadable assets\n * - Saving canvas state\n * @see {@link ExtractSystem.download} For the method that uses these options\n * @see {@link ExtractSystem.image} For creating images without download\n * @category rendering\n * @advanced\n * @interface\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /**\n     * The filename to use when downloading the content.\n     * Should include the desired file extension (e.g., .png).\n     * @default 'image.png'\n     * @example\n     * ```ts\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'my-screenshot.png'\n     * });\n     * ```\n     */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer. Represents a union of all possible extraction option types.\n * Used by various extraction methods to support different output formats and configurations.\n * @example\n * ```ts\n * // Basic canvas extraction\n * const canvas = renderer.extract.canvas({\n *     target: sprite\n * });\n *\n * // Image extraction with format\n * const image = await renderer.extract.image({\n *     target: sprite,\n *     format: 'png',\n *     quality: 1\n * });\n *\n * // Download with filename\n * renderer.extract.download({\n *     target: sprite,\n *     filename: 'screenshot.png'\n * });\n *\n * // Advanced extraction with multiple options\n * const image = await renderer.extract.image({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     format: 'webp',\n *     quality: 0.8\n * });\n * ```\n *\n * Supports three types of options:\n * - {@link BaseExtractOptions} - Basic extraction settings\n * - {@link ExtractImageOptions} - Image-specific settings with format and quality\n * - {@link ExtractDownloadOptions} - Download settings with filename\n *\n * Common use cases:\n * - Extracting raw pixels\n * - Creating canvas elements\n * - Generating downloadable images\n * - Taking screenshots\n * - Creating thumbnails\n * @see {@link ExtractSystem.canvas} For canvas extraction\n * @see {@link ExtractSystem.image} For image extraction\n * @see {@link ExtractSystem.download} For downloading content\n * @category rendering\n * @advanced\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * System for exporting content from a renderer. It provides methods to extract content as images,\n * canvases, or raw pixel data. Available through `renderer.extract`.\n * @example\n * ```ts\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application\n * const app = new Application();\n * await app.init();\n *\n * // Draw something to extract\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill(0xFF0000);\n *\n * // Basic extraction examples\n * const image = await app.renderer.extract.image(graphics);    // As IImage (HTMLImageElement)\n * const canvas = app.renderer.extract.canvas(graphics);        // As Canvas\n * const pixels = app.renderer.extract.pixels(graphics);        // As pixel data\n * const base64 = await app.renderer.extract.base64(graphics); // As base64 string\n *\n * // Advanced extraction with options\n * const customImage = await app.renderer.extract.image({\n *     target: graphics,\n *     format: 'png',\n *     resolution: 2,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     clearColor: '#00000000'\n * });\n *\n * // Download content\n * app.renderer.extract.download({\n *     target: graphics,\n *     filename: 'my-image.png'\n * });\n *\n * // Debug visualization\n * app.renderer.extract.log(graphics);\n * ```\n *\n * Features:\n * - Extract as various formats (PNG, JPEG, WebP)\n * - Control output quality and resolution\n * - Extract specific regions\n * - Download extracted content\n * - Debug visualization\n *\n * Common Use Cases:\n * - Creating thumbnails\n * - Saving game screenshots\n * - Processing visual content\n * - Debugging renders\n * - Creating textures from rendered content\n *\n * Performance Considerations:\n * - Extraction operations are relatively expensive\n * - Consider caching results for frequently used content\n * - Be mindful of resolution and format choices\n * - Large extractions may impact performance\n * @category rendering\n * @standard\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /**\n     * Default options for image extraction.\n     * @example\n     * ```ts\n     * // Customize default options\n     * ExtractSystem.defaultImageOptions.format = 'webp';\n     * ExtractSystem.defaultImageOptions.quality = 0.8;\n     *\n     * // Use defaults\n     * const image = await renderer.extract.image(sprite);\n     * ```\n     */\n    public static defaultImageOptions: ImageOptions = {\n        format: 'png' as Formats,\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Creates an IImage from a display object or texture.\n     * @param options - Options for creating the image, or the target to extract\n     * @returns Promise that resolves with the generated IImage\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const image = await renderer.extract.image(sprite);\n     * document.body.appendChild(image);\n     *\n     * // Advanced usage with options\n     * const image = await renderer.extract.image({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2,\n     *     clearColor: '#ff0000',\n     *     antialias: true\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const image = await renderer.extract.image(texture);\n     * ```\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.base64} For base64 string output\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ImageLike} For the image interface\n     * @category rendering\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<ImageLike>\n    {\n        const image = DOMAdapter.get().createImage();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Converts the target into a base64 encoded string.\n     *\n     * This method works by first creating\n     * a canvas using `Extract.canvas` and then converting it to a base64 string.\n     * @param options - The options for creating the base64 string, or the target to extract\n     * @returns Promise that resolves with the base64 encoded string\n     * @example\n     * ```ts\n     * // Basic usage with a sprite\n     * const sprite = new Sprite(texture);\n     * const base64 = await renderer.extract.base64(sprite);\n     * console.log(base64); // data:image/png;base64,...\n     *\n     * // Advanced usage with options\n     * const base64 = await renderer.extract.base64({\n     *     target: container,\n     *     format: 'webp',\n     *     quality: 0.8,\n     *     frame: new Rectangle(0, 0, 100, 100),\n     *     resolution: 2\n     * });\n     * ```\n     * @throws Will throw an error if the platform doesn't support any of:\n     * - ICanvas.toDataURL\n     * - ICanvas.toBlob\n     * - ICanvas.convertToBlob\n     * @see {@link ExtractImageOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @category rendering\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders the target to it and returns it.\n     * This method is useful for creating static images or when you need direct canvas access.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns A Canvas element with the texture rendered on\n     * @example\n     * ```ts\n     * // Basic canvas extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const canvas = renderer.extract.canvas(sprite);\n     * document.body.appendChild(canvas);\n     *\n     * // Extract with custom region\n     * const canvas = renderer.extract.canvas({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const canvas = renderer.extract.canvas({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Extract directly from a texture\n     * const texture = Texture.from('myTexture.png');\n     * const canvas = renderer.extract.canvas(texture);\n     *\n     * // Extract with anti-aliasing\n     * const canvas = renderer.extract.canvas({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.image} For HTMLImage output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Returns a one-dimensional array containing the pixel data of the entire texture in RGBA order,\n     * with integer values between 0 and 255 (inclusive).\n     * > [!NOE] The returned array is a flat Uint8Array where every 4 values represent RGBA\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns One-dimensional Uint8Array containing the pixel data in RGBA format\n     * @example\n     * ```ts\n     * // Basic pixel extraction\n     * const sprite = new Sprite(texture);\n     * const pixels = renderer.extract.pixels(sprite);\n     * console.log(pixels[0], pixels[1], pixels[2], pixels[3]); // R,G,B,A values\n     *\n     * // Extract with custom region\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const pixels = renderer.extract.pixels({\n     *     target: sprite,\n     *     resolution: 2\n     * });\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @see {@link ExtractSystem.image} For image output\n     * @category rendering\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Creates a texture from a display object or existing texture.\n     *\n     * This is useful for creating\n     * reusable textures from rendered content or making copies of existing textures.\n     * > [!NOTE] The returned texture should be destroyed when no longer needed\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns A new texture containing the extracted content\n     * @example\n     * ```ts\n     * // Basic texture extraction from a sprite\n     * const sprite = new Sprite(texture);\n     * const extractedTexture = renderer.extract.texture(sprite);\n     *\n     * // Extract with custom region\n     * const regionTexture = renderer.extract.texture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Extract with high resolution\n     * const hiResTexture = renderer.extract.texture({\n     *     target: sprite,\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Create a new sprite from extracted texture\n     * const newSprite = new Sprite(\n     *     renderer.extract.texture({\n     *         target: graphics,\n     *         antialias: true\n     *     })\n     * );\n     *\n     * // Clean up when done\n     * extractedTexture.destroy(true);\n     * ```\n     * @see {@link ExtractOptions} For detailed options\n     * @see {@link Texture} For texture management\n     * @see {@link GenerateTextureSystem} For texture generation\n     * @category rendering\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Extracts and downloads content from the renderer as an image file.\n     * This is a convenient way to save screenshots or export rendered content.\n     * > [!NOTE] The download will use PNG format regardless of the filename extension\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     * @example\n     * ```ts\n     * // Basic download with default filename\n     * const sprite = new Sprite(texture);\n     * renderer.extract.download(sprite); // Downloads as 'image.png'\n     *\n     * // Download with custom filename\n     * renderer.extract.download({\n     *     target: sprite,\n     *     filename: 'screenshot.png'\n     * });\n     *\n     * // Download with custom region\n     * renderer.extract.download({\n     *     target: container,\n     *     filename: 'region.png',\n     *     frame: new Rectangle(0, 0, 100, 100)\n     * });\n     *\n     * // Download with high resolution and background\n     * renderer.extract.download({\n     *     target: stage,\n     *     filename: 'hd-screenshot.png',\n     *     resolution: 2,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Download with anti-aliasing\n     * renderer.extract.download({\n     *     target: graphics,\n     *     filename: 'smooth.png',\n     *     antialias: true\n     * });\n     * ```\n     * @see {@link ExtractDownloadOptions} For detailed options\n     * @see {@link ExtractSystem.image} For creating images without download\n     * @see {@link ExtractSystem.canvas} For canvas output\n     * @category rendering\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        /* eslint-disable no-restricted-globals */\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        /* eslint-enable no-restricted-globals */\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * The image will be displayed in the browser's console using CSS background images.\n     * @param options - The options for logging the image, or the target to log\n     * @param options.width - The width of the logged image preview in the console (in pixels)\n     * @example\n     * ```ts\n     * // Basic usage\n     * const sprite = new Sprite(texture);\n     * renderer.extract.log(sprite);\n     * ```\n     * @see {@link ExtractSystem.canvas} For getting raw canvas output\n     * @see {@link ExtractSystem.pixels} For raw pixel data\n     * @category rendering\n     * @advanced\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link Texture}\n * @category rendering\n * @advanced\n */\nexport class RenderTexture extends Texture\n{\n    /**\n     * Creates a RenderTexture. Pass `dynamic: true` in options to allow resizing after creation.\n     * @param options - Options for the RenderTexture, including width, height, and dynamic.\n     * @returns A new RenderTexture instance.\n     * @example\n     * const rt = RenderTexture.create({ width: 100, height: 100, dynamic: true });\n     * rt.resize(500, 500);\n     */\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        // Pass dynamic to the RenderTexture constructor if present in options\n        const { dynamic, ...rest } = options;\n\n        return new RenderTexture({\n            source: new TextureSource(rest),\n            dynamic: dynamic ?? false,\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n","import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\n/**\n * Options for generating a texture source.\n * @category rendering\n * @advanced\n * @interface\n */\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * Used to create reusable textures from display objects, which can improve performance\n * when the same content needs to be rendered multiple times.\n * @example\n * ```ts\n * // Basic texture generation\n * const sprite = new Sprite(texture);\n * const generatedTexture = renderer.generateTexture({\n *     target: sprite\n * });\n *\n * // Generate with custom region and resolution\n * const texture = renderer.generateTexture({\n *     target: container,\n *     frame: new Rectangle(0, 0, 100, 100),\n *     resolution: 2\n * });\n *\n * // Generate with background color and anti-aliasing\n * const highQualityTexture = renderer.generateTexture({\n *     target: graphics,\n *     clearColor: '#ff0000',\n *     antialias: true,\n *     textureSourceOptions: {\n *         scaleMode: 'linear'\n *     }\n * });\n * ```\n * @category rendering\n * @advanced\n */\nexport type GenerateTextureOptions = {\n    /**\n     * The container to generate the texture from.\n     * This can be any display object like Sprite, Container, or Graphics.\n     * @example\n     * ```ts\n     * const graphics = new Graphics()\n     *     .circle(0, 0, 50)\n     *     .fill('red');\n     *\n     * const texture = renderer.generateTexture({\n     *     target: graphics\n     * });\n     * ```\n     */\n    target: Container;\n\n    /**\n     * The region of the container that should be rendered.\n     * If not specified, defaults to the local bounds of the container.\n     * @example\n     * ```ts\n     * // Extract only a portion of the container\n     * const texture = renderer.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(10, 10, 100, 100)\n     * });\n     * ```\n     */\n    frame?: Rectangle;\n\n    /**\n     * The resolution of the texture being generated.\n     * Higher values create sharper textures at the cost of memory.\n     * @default renderer.resolution\n     * @example\n     * ```ts\n     * // Generate a high-resolution texture\n     * const hiResTexture = renderer.generateTexture({\n     *     target: sprite,\n     *     resolution: 2 // 2x resolution\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * The color used to clear the texture before rendering.\n     * Can be a hex number, string, or array of numbers.\n     * @example\n     * ```ts\n     * // Clear with red background\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: '#ff0000'\n     * });\n     *\n     * // Clear with semi-transparent black\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     clearColor: [0, 0, 0, 0.5]\n     * });\n     * ```\n     */\n    clearColor?: ColorSource;\n\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @default false\n     * @example\n     * ```ts\n     * // Generate a smooth texture\n     * const texture = renderer.generateTexture({\n     *     target: graphics,\n     *     antialias: true\n     * });\n     * ```\n     */\n    antialias?: boolean;\n\n    /**\n     * Advanced options for configuring the texture source.\n     * Controls texture properties like scale mode and filtering.\n     * @advanced\n     * @example\n     * ```ts\n     * const texture = renderer.generateTexture({\n     *     target: sprite,\n     *     textureSourceOptions: {\n     *         scaleMode: 'linear',\n     *     }\n     * });\n     * ```\n     */\n    textureSourceOptions?: GenerateTextureSourceOptions;\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from display objects in the renderer.\n * This system is responsible for creating reusable textures from containers, sprites, and other display objects.\n * Available through `renderer.textureGenerator`.\n * @example\n * ```ts\n * import { Application, Sprite, Graphics } from 'pixi.js';\n *\n * const app = new Application();\n * await app.init();\n *\n * // Create a complex display object\n * const container = new Container();\n *\n * const graphics = new Graphics()\n *     .circle(0, 0, 50)\n *     .fill('red');\n *\n * const sprite = new Sprite(texture);\n * sprite.x = 100;\n *\n * container.addChild(graphics, sprite);\n *\n * // Generate a texture from the container\n * const generatedTexture = app.renderer.textureGenerator.generateTexture({\n *     target: container,\n *     resolution: 2,\n *     antialias: true\n * });\n *\n * // Use the generated texture\n * const newSprite = new Sprite(generatedTexture);\n * app.stage.addChild(newSprite);\n *\n * // Clean up when done\n * generatedTexture.destroy(true);\n * ```\n *\n * Features:\n * - Convert any display object to a texture\n * - Support for custom regions and resolutions\n * - Anti-aliasing support\n * - Background color configuration\n * - Texture source options customization\n *\n * Common Use Cases:\n * - Creating texture atlases dynamically\n * - Caching complex container content\n * - Generating thumbnails\n * - Creating reusable textures from rendered content\n *\n * Performance Considerations:\n * - Generating textures is relatively expensive\n * - Cache results when possible\n * - Be mindful of resolution and size\n * - Clean up unused textures\n * @see {@link GenerateTextureOptions} For detailed texture generation options\n * @see {@link AbstractRenderer.generateTexture} For the main renderer method\n * @see {@link RenderTexture} For the resulting texture type\n * @category rendering\n * @standard\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Creates a texture from a display object that can be used for creating sprites and other textures.\n     * This is particularly useful for optimizing performance when a complex container needs to be reused.\n     * @param options - Generate texture options or a container to convert to texture\n     * @returns A new RenderTexture containing the rendered display object\n     * @example\n     * ```ts\n     * // Basic usage with a container\n     * const container = new Container();\n     * container.addChild(\n     *     new Graphics()\n     *         .circle(0, 0, 50)\n     *         .fill('red')\n     * );\n     *\n     * const texture = renderer.textureGenerator.generateTexture(container);\n     *\n     * // Advanced usage with options\n     * const texture = renderer.textureGenerator.generateTexture({\n     *     target: container,\n     *     frame: new Rectangle(0, 0, 100, 100), // Specific region\n     *     resolution: 2,                        // High DPI\n     *     clearColor: '#ff0000',               // Red background\n     *     antialias: true                      // Smooth edges\n     * });\n     *\n     * // Create a sprite from the generated texture\n     * const sprite = new Sprite(texture);\n     *\n     * // Clean up when done\n     * texture.destroy(true);\n     * ```\n     * @see {@link GenerateTextureOptions} For detailed texture generation options\n     * @see {@link RenderTexture} For the type of texture created\n     * @category rendering\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../scene/container/RenderGroup';\nimport { type GPUDataOwner, type Renderer } from '../types';\nimport { type Renderable } from './Renderable';\nimport { type RenderOptions } from './system/AbstractRenderer';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { System } from './system/System';\n\n/**\n * Data stored on a GC-managed resource.\n * @category rendering\n * @advanced\n */\nexport interface GCData\n{\n    /** Index in the managed resources array */\n    index?: number;\n    /** Type of the resource */\n    type: 'resource' | 'renderable';\n}\n\n/**\n * Interface for resources that can be garbage collected.\n * @category rendering\n * @advanced\n */\nexport interface GCable extends GPUDataOwner\n{\n    /** Timestamp of last use */\n    _gcLastUsed: number;\n    /** GC tracking data, null if not being tracked */\n    _gcData?: GCData | null;\n    /** If set to true, the resource will be garbage collected automatically when it is not used. */\n    autoGarbageCollect?: boolean;\n    /** An optional callback for when an item is touched */\n    _onTouch?(now: number): void;\n}\n\ntype GCableEventEmitter = GCable & Pick<EventEmitter, 'once' | 'off'>;\n\ninterface GCResourceHashEntry\n{\n    context: any;\n    hash: string;\n    type: GCData['type'];\n    priority: number;\n}\n\n/**\n * Options for the {@link GCSystem}.\n * @category rendering\n * @advanced\n */\nexport interface GCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector.\n     * @default true\n     */\n    gcActive: boolean;\n    /**\n     * The maximum time in milliseconds a resource can be unused before being garbage collected.\n     * @default 60000\n     */\n    gcMaxUnusedTime: number;\n    /**\n     * How frequently to run garbage collection in milliseconds.\n     * @default 30000\n     */\n    gcFrequency: number;\n}\n\n/**\n * A unified garbage collection system for managing GPU resources.\n * Resources register themselves with a cleanup callback and are automatically\n * cleaned up when they haven't been used for a specified amount of time.\n * @example\n * ```ts\n * // Register a resource for GC\n * gc.addResource(myResource, () => {\n *     // cleanup logic here\n *     myResource.unload();\n * });\n *\n * // Touch the resource when used (resets idle timer)\n * gc.touch(myResource);\n *\n * // Remove from GC tracking (e.g., on manual destroy)\n * gc.removeResource(myResource);\n * ```\n * @category rendering\n * @advanced\n */\nexport class GCSystem implements System<GCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'gc',\n        priority: 0,\n    } as const;\n\n    /** Default options for the GCSystem */\n    public static defaultOptions: GCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        gcActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        gcMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        gcFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of resources being tracked for garbage collection */\n    private readonly _managedResources: GCableEventEmitter[] = [];\n    private readonly _managedResourceHashes: GCResourceHashEntry[] = [];\n\n    /** ID of the GC scheduler handler */\n    private _handler: number;\n\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n\n    /** Current timestamp used for age calculations */\n    public now: number;\n\n    private _ready = false;\n\n    /**\n     * Creates a new GCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options\n     */\n    public init(options: GCSystemOptions): void\n    {\n        options = { ...GCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.gcMaxUnusedTime;\n        this._frequency = options.gcFrequency;\n\n        this.enabled = options.gcActive;\n        this.now = performance.now();\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            this._handler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    this._ready = true;\n                },\n                this._frequency,\n                false\n            );\n        }\n        else\n        {\n            this._renderer.scheduler.cancel(this._handler);\n            this._handler = 0;\n        }\n    }\n\n    /**\n     * Called before rendering. Updates the current timestamp.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    protected prerender({ container }: RenderOptions): void\n    {\n        this.now = performance.now();\n        container.renderGroup.gcTick = this._renderer.tick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /** Performs garbage collection after rendering. */\n    protected postrender(): void\n    {\n        if (!this._ready || !this.enabled) return;\n\n        this.run();\n        this._ready = false;\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n\n    /**\n     * Registers a resource for garbage collection tracking.\n     * @param resource - The resource to track\n     * @param type - The type of resource to track\n     */\n    public addResource(resource: GCableEventEmitter, type: GCData['type']): void\n    {\n        // Already being tracked\n        if (resource._gcLastUsed !== -1)\n        {\n            resource._gcLastUsed = this.now;\n            resource._onTouch?.(this.now);\n\n            return;\n        }\n\n        const index = this._managedResources.length;\n\n        resource._gcData = {\n            index,\n            type,\n        };\n        resource._gcLastUsed = this.now;\n        resource._onTouch?.(this.now);\n        resource.once('unload', this.removeResource, this);\n\n        this._managedResources.push(resource);\n    }\n\n    /**\n     * Removes a resource from garbage collection tracking.\n     * Call this when manually destroying a resource.\n     * @param resource - The resource to stop tracking\n     */\n    public removeResource(resource: GCable): void\n    {\n        const gcData = resource._gcData;\n\n        if (!gcData) return;\n\n        const index = gcData.index;\n        const last = this._managedResources.length - 1;\n\n        // Swap with last element for O(1) removal\n        if (index !== last)\n        {\n            const lastResource = this._managedResources[last];\n\n            this._managedResources[index] = lastResource;\n            lastResource._gcData.index = index;\n        }\n\n        this._managedResources.length--;\n        resource._gcData = null;\n        resource._gcLastUsed = -1;\n    }\n\n    /**\n     * Registers a hash-based resource collection for garbage collection tracking.\n     * Resources in the hash will be automatically tracked and cleaned up when unused.\n     * @param context - The object containing the hash property\n     * @param hash - The property name on context that holds the resource hash\n     * @param type - The type of resources in the hash ('resource' or 'renderable')\n     * @param priority - Processing priority (lower values are processed first)\n     */\n    public addResourceHash(context: any, hash: string, type: GCData['type'], priority: number = 0): void\n    {\n        this._managedResourceHashes.push({\n            context,\n            hash,\n            type,\n            priority,\n        });\n\n        this._managedResourceHashes.sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused resources.\n     * Removes resources that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = performance.now();\n        const managedResourceHashes = this._managedResourceHashes;\n\n        for (const hashEntry of managedResourceHashes)\n        {\n            this.runOnHash(hashEntry, now);\n        }\n\n        let writeIndex = 0;\n\n        for (let i = 0; i < this._managedResources.length; i++)\n        {\n            const resource = this._managedResources[i];\n\n            writeIndex = this.runOnResource(resource, now, writeIndex);\n        }\n\n        this._managedResources.length = writeIndex;\n    }\n\n    protected updateRenderableGCTick(renderable: Renderable & GCable, now: number): void\n    {\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n        const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n        // Update last used time if the renderable's group was rendered this tick\n        if ((renderGroup?.gcTick ?? 0) === currentTick)\n        {\n            renderable._gcLastUsed = now;\n            renderable._onTouch?.(now);\n        }\n    }\n\n    protected runOnResource(resource: GCableEventEmitter, now: number, writeIndex: number): number\n    {\n        const gcData = resource._gcData;\n\n        // special case for renderables as we do not check every frame if they are being used\n        if (gcData.type === 'renderable')\n        {\n            this.updateRenderableGCTick(resource as Renderable, now);\n        }\n\n        const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n\n        if (isRecentlyUsed || !resource.autoGarbageCollect)\n        {\n            this._managedResources[writeIndex] = resource;\n            gcData.index = writeIndex;\n            writeIndex++;\n        }\n        else\n        {\n            // Call the cleanup function\n            resource.unload();\n            resource._gcData = null;\n            resource._gcLastUsed = -1;\n            resource.off('unload', this.removeResource, this);\n        }\n\n        return writeIndex;\n    }\n\n    /**\n     * Creates a clone of the hash, copying all non-null entries up to (but not including) the stop key.\n     * @param hashValue - The original hash to clone from\n     * @param stopKey - The key to stop at (exclusive)\n     * @returns A new hash object with copied entries\n     */\n    private _createHashClone(hashValue: Record<string, GCable>, stopKey: string): Record<string, GCable>\n    {\n        const hashClone: Record<string, GCable> = Object.create(null);\n\n        for (const k in hashValue)\n        {\n            if (k === stopKey) break;\n            if (hashValue[k] !== null) hashClone[k] = hashValue[k];\n        }\n\n        return hashClone;\n    }\n\n    protected runOnHash(hashEntry: GCResourceHashEntry, now: number): void\n    {\n        const { context, hash, type } = hashEntry;\n\n        const hashValue = context[hash] as Record<string, GCable>;\n        let hashClone: Record<string, GCable> | null = null;\n        let nullCount = 0;\n\n        for (const key in hashValue)\n        {\n            const resource = hashValue[key];\n\n            // check if the value is null\n            if (resource === null)\n            {\n                nullCount++;\n\n                // Lazily create the clone to clean up null entries when threshold is reached\n                if (nullCount === 10000 && !hashClone)\n                {\n                    hashClone = this._createHashClone(hashValue, key);\n                }\n\n                continue;\n            }\n\n            // If no GC data, then the resource has been added since the last garbage collection\n            if (resource._gcLastUsed === -1)\n            {\n                resource._gcLastUsed = now;\n                resource._onTouch?.(now);\n\n                if (hashClone) hashClone[key] = resource;\n\n                continue;\n            }\n\n            // special case for renderables as we do not check every frame if they are being used\n            if (type === 'renderable')\n            {\n                this.updateRenderableGCTick(resource as Renderable, now);\n            }\n\n            const isRecentlyUsed = now - resource._gcLastUsed < this.maxUnusedTime;\n\n            if (!isRecentlyUsed && resource.autoGarbageCollect)\n            {\n                // Lazily create the clone only when we need to remove something\n                if (!hashClone)\n                {\n                    // we can set the value to null here to avoid having to create a new hash object\n                    // only when it crosses the 10000 threshold do we need to create a new hash object\n                    if (nullCount + 1 !== 10000)\n                    {\n                        hashValue[key] = null;\n                        nullCount++;\n                    }\n                    else\n                    {\n                        hashClone = this._createHashClone(hashValue, key);\n                    }\n                }\n\n                // Call the cleanup function\n                resource.unload();\n                resource._gcData = null;\n                resource._gcLastUsed = -1;\n            }\n            else if (hashClone)\n            {\n                hashClone[key] = resource;\n            }\n        }\n\n        // Only replace the hash if something was removed\n        if (hashClone)\n        {\n            context[hash] = hashClone;\n        }\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n\n        this._managedResources.forEach((resource) =>\n        {\n            resource.off('unload', this.removeResource, this);\n        });\n        this._managedResources.length = 0;\n        this._managedResourceHashes.length = 0;\n        this._renderer = null as any as Renderer;\n    }\n}\n\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\n/**\n * Type definition for the global uniforms used in the renderer.\n * This includes projection matrix, world transform matrix, world color, and resolution.\n * @category rendering\n * @advanced\n */\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\n/**\n * Options for the global uniforms system.\n * This includes size, projection matrix, world transform matrix, world color, and offset.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\n/**\n * Data structure for the global uniforms used in the renderer.\n * This includes the projection matrix, world transform matrix, world color, resolution, and bind group.\n * @category rendering\n * @advanced\n */\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\n/** @internal */\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @category rendering\n * @advanced\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._globalUniformDataStack.length = 0;\n        this._uniformsPool.length = 0;\n        this._activeUniforms.length = 0;\n        this._bindGroupPool.length = 0;\n        this._activeBindGroups.length = 0;\n        this._currentGlobalUniformData = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @category rendering\n * @advanced\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n","import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n * @category utils\n * @advanced\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @category rendering\n * @advanced\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @category rendering\n * @advanced\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n","/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @category utils\n * @internal\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @category utils\n * @internal\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\nimport { type RenderOptions } from '../system/AbstractRenderer';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\nlet renderableGCTick = 0;\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @category rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n * @advanced\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n * @example\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of renderables being tracked for garbage collection */\n    private readonly _managedRenderables: Renderable[] = [];\n    /** ID of the main GC scheduler handler */\n    private _handler: number;\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n    /** Current timestamp used for age calculations */\n    private _now: number;\n\n    /** Array of hash objects being tracked for cleanup */\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    /** ID of the hash cleanup scheduler handler */\n    private _hashHandler: number;\n\n    /** Array of arrays being tracked for cleanup */\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    /** ID of the array cleanup scheduler handler */\n    private _arrayHandler: number;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            // Schedule periodic garbage collection\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            // Schedule periodic hash table cleanup\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            // Schedule periodic array cleanup\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            // Cancel all scheduled cleanups\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Updates the GC timestamp and tracking before rendering.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    public prerender({\n        container\n    }: RenderOptions): void\n    {\n        this._now = performance.now();\n\n        // The gcTick is a monotonically increasing counter that tracks render cycles\n        // Each time we render, we increment the global renderableGCTick counter\n        // and assign the new tick value to the render group being rendered.\n        // This lets us know which render groups were rendered in the current frame\n        // versus ones that haven't been rendered recently.\n        // The instruction set also gets updated with this tick value to track\n        // when its renderables were last used.\n        container.renderGroup.gcTick = renderableGCTick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param renderable - The renderable to track\n     */\n    public addRenderable(renderable: Renderable): void\n    {\n        if (!this.enabled) return;\n\n        if (renderable._lastUsed === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastUsed = this._now;\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n            // Update last used time if the renderable's group was rendered this tick\n            if ((renderGroup?.gcTick ?? 0) === currentTick)\n            {\n                renderable._lastUsed = now;\n            }\n\n            // Clean up if unused for too long\n            if (now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    if (renderGroup)renderGroup.structureDidChange = true;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    /**\n     * Removes a renderable from being tracked when it's destroyed.\n     * @param renderable - The renderable to stop tracking\n     */\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n}\n","import { ExtensionType } from '../../../../extensions/Extensions';\nimport { deprecation } from '../../../../utils/logging/deprecation';\nimport { type Renderer } from '../../types';\n\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @deprecated since 8.15.0\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @deprecated since 8.15.0\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @deprecated since 8.15.0\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @category rendering\n * @advanced\n * @deprecated since 8.15.0\n * @see {@link GCSystem}\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /**\n     * Default options for the TextureGCSystem\n     * @deprecated since 8.15.0\n     */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystemOptions.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     * @deprecated since 8.15.0\n     */\n    public get count() { return this._renderer.tick; }\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     * @deprecated since 8.15.0\n     */\n    public get checkCount() { return this._checkCount; }\n    public set checkCount(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._checkCount = value;\n    }\n    private _checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     * @deprecated since 8.15.0\n     */\n    public get maxIdle() { return (this._renderer.gc.maxUnusedTime / 1000) * 60; }\n    public set maxIdle(value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.maxUnusedTime = (value / 60) * 1000;\n    }\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     * @deprecated since 8.15.0\n     */\n    // eslint-disable-next-line dot-notation\n    public get checkCountMax() { return Math.floor(this._renderer.gc['_frequency'] / 1000); }\n    public set checkCountMax(_value: number)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n    }\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     * @deprecated since 8.15.0\n     */\n    public get active() { return this._renderer.gc.enabled; }\n    public set active(value: boolean)\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.enabled = value;\n    }\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        if (options.textureGCActive !== TextureGCSystem.defaultOptions.textureGCActive)\n        { this.active = options.textureGCActive; }\n        if (options.textureGCMaxIdle !== TextureGCSystem.defaultOptions.textureGCMaxIdle)\n        { this.maxIdle = options.textureGCMaxIdle; }\n        if (options.textureGCCheckCountMax !== TextureGCSystem.defaultOptions.textureGCCheckCountMax)\n        { this.checkCountMax = options.textureGCCheckCountMax; }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     * @deprecated since 8.15.0\n     */\n    public run(): void\n    {\n        // #if _DEBUG\n        deprecation('8.15.0', 'TextureGCSystem.run is deprecated, please use the GCSystem instead.');\n        // #endif\n        this._renderer.gc.run();\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { type RendererOptions } from '../../types';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     */\n    height?: number;\n    /** The canvas to use as a view, optional. */\n    canvas?: ICanvas;\n    /**\n     * Alias for `canvas`.\n     * @deprecated since 8.0.0\n     */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     *\n     * This is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** The resolution / device pixel ratio of the renderer. */\n    resolution?: number;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer. */\n    depth?: boolean;\n}\n\n/**\n * Options for destroying the ViewSystem.\n * @category rendering\n * @advanced\n */\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @category rendering\n * @advanced\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions> >\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n     * @type {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = (options as RendererOptions).backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @example\n     * viewSystem.destroy();\n     * viewSystem.destroy(true);\n     * viewSystem.destroy({ removeView: true });\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        this.texture.destroy();\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GCSystem } from '../GCSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\n/**\n * Shared systems for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    GCSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\n/**\n * Shared render pipes for the renderer.\n * @category rendering\n * @internal\n */\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @category rendering\n * @advanced\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n","/** @internal */\nexport const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n\n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\n/** @internal */\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n\n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n","import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in any gaps. We do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of the time users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way,\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n * @internal\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n","import { GlobalResourceRegistry } from '../../../../../utils/pool/GlobalResourceRegistry';\nimport { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nGlobalResourceRegistry.register(canvasCache);\n\n/**\n * @param canvas\n * @param options\n * @internal\n */\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\n/**\n * @param canvas\n * @internal\n */\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n","import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\n/** @internal */\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\n/** @internal */\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n","import { STENCIL_MODES } from '../../shared/state/const';\n\n/**\n * The stencil state for the GPU renderer.\n * This is used to define how the stencil buffer should be configured.\n * @category rendering\n * @advanced\n */\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\n/** @internal */\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'keep',\n    },\n};\n","import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @category rendering\n * @see environment.ICanvas\n * @see Texture\n * @see RenderTarget\n * @advanced\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @category rendering\n * @advanced\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture.\n     *\n     * NOTE:\n     * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n     *\n     * The following is not valid:\n     * @example\n     * const canvas = document.createElement('canvas')\n     * canvas.width = 200;\n     * canvas.height = 200;\n     *\n     * const ctx = canvas2.getContext('2d')!\n     * ctx.fillStyle = 'red'\n     * ctx.fillRect(0, 0, 200, 200);\n     *\n     * const texture = RenderTexture.create({\n     *   width: 200,\n     *   height: 200,\n     * })\n     * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n     *\n     * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n     *\n     * The best way to copy a canvas is to create a texture from it. Then render with that.\n     *\n     * Parsing in a RenderTarget canvas context (with a 2d context)\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (renderSurface.source instanceof CanvasSource)\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n\n    public resetState(): void\n    {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n","/* eslint-disable no-restricted-globals */\nimport type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n * @internal\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n","import type { Matrix } from '../../../../maths/matrix/Matrix';\n\n/**\n * @param pm\n * @param x\n * @param y\n * @param width\n * @param height\n * @param flipY\n * @internal\n */\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n","import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\n/**\n * @param uboElements\n * @param parserCode\n * @param arrayGenerationFunction\n * @param singleSettersMap\n * @internal\n */\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n","// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\ninterface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\n/** @internal */\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\n/** @internal */\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @category rendering\n * @advanced\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n","/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @category rendering\n * @advanced\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n        this.removeAllListeners();\n    }\n}\n"],"names":["_RenderTarget","constructor","descriptor","arguments","length","undefined","uid","colorTextures","dirtyId","isRoot","_size","Float32Array","_managedColorTextures","_objectSpread","defaultOptions","this","stencil","depth","i","push","TextureSource","width","height","resolution","antialias","map","texture","source","colorSource","colorTexture","resize","_resolution","on","onSourceResize","depthStencilTexture","Texture","ensureDepthStencilTexture","size","pixelWidth","pixelHeight","format","autoGenerateMipmaps","mipLevelCount","skipColorTexture","forEach","destroy","off","RenderTarget","localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","BatchableSprite","batcherName","topology","attributeSize","indexSize","packAsQuad","roundPixels","_attributeStart","_batcher","_batch","blendMode","renderable","groupBlendMode","color","groupColorAlpha","reset","bounds","CustomRenderPipe","renderer","_renderer","updateRenderable","destroyRenderable","validateRenderable","addRenderable","container","instructionSet","renderPipes","batch","break","add","execute","isRenderable","render","extension","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","executeInstructions","renderGroup","instructions","instructionSize","instruction","renderPipeId","tempMatrix","Matrix","RenderGroupPipe","addRenderGroup","isCachedAsTexture","_addRenderableCacheAsTexture","_addRenderableDirect","_executeCacheAsTexture","_executeDirect","_batchableRenderGroup","BigPool","return","_renderGroup$_batchab","batchableRenderGroup","get","root","transform","relativeGroupTransform","_textureBounds","pushBlendMode","addToBatch","popBlendMode","textureNeedsUpdate","worldTransformMatrix","identity","translate","x","y","renderTarget","frame","globalUniforms","worldColor","offset","finishRenderPass","pop","updateElement","geometry","buffers","update","inverseParentTextureTransform","worldColorAlpha","clearList","list","index","j","tempContainer","Container","UPDATE_BLEND_COLOR_VISIBLE","UPDATE_VISIBLE","UPDATE_COLOR","UPDATE_BLEND","updateRenderGroupTransforms","updateChildRenderGroups","worldAlpha","renderGroupParent","worldTransform","appendFrom","multiplyColors","groupColor","groupAlpha","copyFrom","localTransform","localColor","localAlpha","updateRenderGroupTransform","childrenToUpdate","updateTick","renderGroupDepth","Number","childrenAtDepth","child","parentRenderGroup","relativeRenderGroupDepth","updateTransformAndChildren","renderGroupChildren","updateFlags","didChange","updateLocalTransform","parent","_updateFlags","updateColorBlendVisibility","children","structureDidChange","localBlendMode","globalDisplayStatus","localDisplayStatus","RenderGroupSystem","_ref","originalLocalTransform","_updateCachedRenderGroups","_updateRenderGroups","start","uniformBatch","renderEnd","closestCacheAsTexture","_parentCacheAsTextureRenderGroup","invalidateMatrices","_renderGroup$textureO","_renderGroup$textureO2","getLocalBounds","ceil","lastTexture","TexturePool","returnTexture","textureOptions","view","scaleMode","getOptimalTexture","_source","style","TextureStyle","Bounds","runOnRender","childrenRenderablesToUpdate","rebuildRequired","validateRenderables","_buildInstructions","_updateRenderables","upload","didViewUpdate","rendererOrPipes","buildStart","colorMask","sortableChildren","sortChildren","collectRenderablesWithEffects","buildEnd","WebGLSystem","WebGPUSystem","CanvasSystem","SpritePipe","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","checkAndUpdateTexture","_texture","batchableSprite","visualBounds","_gpuData","_initGPUSprite","groupTransform","_roundPixels","_BatcherPipe","adaptor","_this$_adaptor$init","_this$_adaptor","state","State","for2d","_batchersByInstructionSet","Object","create","_activeBatches","_adaptor","init","call","getBatcher","_availableBatchers","batchers","default","DefaultBatcher","maxTextures","limits","maxBatchableTextures","_activeBatch","begin","batchableObject","batches","indexBuffer","setDataWithSize","attributeBuffer","float32View","batcher","dirty","action","shader","BatcherPipe","extensions","handleByMap","Batcher","MaskFilter","Filter","options","rest","_objectWithoutProperties","_excluded","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","uFilterMatrix","value","uMaskClamp","uClampFrame","uAlpha","uInverse","inverse","gpuProgram","GpuProgram","from","entryPoint","fragment","glProgram","GlProgram","clipToViewport","resources","uMaskTexture","_textureMatrix","uniforms","apply","filterManager","input","output","clearMode","calculateSpriteMatrix","prepend","mapCoord","applyFilter","tempBounds","AlphaMaskEffect","FilterEffect","filters","Sprite","EMPTY","AlphaMaskPipe","_activeMaskStage","mask","maskedContainer","_maskOptions","canBundle","renderMaskToTexture","maskContainer","includeInBuild","collectRenderables","_maskedContainer","renderMask","filterEffect","measurable","getGlobalBounds","colorTextureSource","filterTexture","tx","minX","ty","minY","maskData","RendererType","WEBGL","filter","ColorMaskPipe","_colorStack","_colorStackIndex","_currentColor","_container","colorStack","currentColor","_mask","setMask","StencilMaskPipe","_maskStackHash","_maskHash","WeakMap","_a$renderTargetUid","_a","effect","setBlendMode","has","set","instructionsStart","instructionsLength","renderTargetUid","_a$renderTargetUid2","maskStackIndex","ensureDepthStencil","setStencilMode","STENCIL_MODES","RENDERING_MASK_ADD","INVERSE_MASK_ACTIVE","MASK_ACTIVE","RENDERING_MASK_REMOVE","clear","CLEAR","STENCIL","DISABLED","_BackgroundSystem","clearBeforeRender","_backgroundColor","Color","alpha","background","backgroundColor","backgroundAlpha","setAlpha","shared","setValue","warn","colorRgba","toArray","priority","BackgroundSystem","BLEND_MODE_FILTERS","handle","BlendMode","Error","ref","BlendModePipe","_blendModeStack","_isAdvanced","_filterHash","runners","prerender","_activeBlendMode","_this$_blendModeStack","isRenderGroup","RenderGroup","_this$_renderableList","_endAdvancedBlendMode","_beginAdvancedBlendMode","_renderableList","concat","_ensureFilterEffect","renderables","imageTypes","png","jpg","webp","_ExtractSystem","_normalizeOptions","defaults","target","image","DOMAdapter","createImage","src","base64","defaultImageOptions","quality","canvas","toBlob","Promise","resolve","reject","blob","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","generateCanvas","textureGenerator","generateTexture","pixels","pixelInfo","getPixels","download","_options$filename","link","document","createElement","filename","href","body","appendChild","click","removeChild","log","_options$width","console","join","ExtractSystem","RenderTexture","dynamic","tempRect","Rectangle","noColor","GenerateTextureSystem","_options$frame","textureSourceOptions","clearColor","Array","isArray","region","copyTo","rectangle","Math","max","updateMipmaps","_GCSystem","_managedResources","_managedResourceHashes","_ready","maxUnusedTime","gcMaxUnusedTime","_frequency","gcFrequency","enabled","gcActive","now","performance","_handler","scheduler","repeat","cancel","gcTick","tick","_updateInstructionGCTick","postrender","run","addResource","resource","_resource$_onTouch2","_resource$_onTouch","_gcLastUsed","_onTouch","_gcData","once","removeResource","gcData","last","lastResource","addResourceHash","context","hash","sort","a","b","managedResourceHashes","hashEntry","runOnHash","writeIndex","runOnResource","updateRenderableGCTick","_renderable$renderGro","_renderGroup$instruct","_renderGroup$instruct2","_renderGroup$gcTick","currentTick","_renderable$_onTouch","autoGarbageCollect","unload","_createHashClone","hashValue","stopKey","hashClone","k","nullCount","key","_resource$_onTouch3","GCSystem","GlobalUniformSystem","_stackIndex","_globalUniformDataStack","_uniformsPool","_activeUniforms","_bindGroupPool","_activeBindGroups","bind","projectionMatrix","currentGlobalUniformData","projectionData","Point","globalUniformData","bindGroup","uniformGroup","_createUniforms","uProjectionMatrix","uResolution","uWorldTransformMatrix","color32BitToUniform","uWorldColorAlpha","getUniformBindGroup","BindGroup","setResource","_currentGlobalUniformData","isStatic","SchedulerSystem","_tasks","_offset","Ticker","system","_update","func","duration","id","splice","task","elapsed","remove","saidHello","HelloSystem","hello","webGLVersion","getNavigator","userAgent","toLowerCase","indexOf","args","VERSION","globalThis","sayHello","cleanHash","clean","cleanHash2","cleanArray","arr","renderableGCTick","_RenderableGCSystem","_managedRenderables","_managedHashes","_managedArrays","renderableGCMaxUnusedTime","renderableGCFrequency","renderableGCActive","_hashHandler","_arrayHandler","array","addManagedHash","addManagedArray","_now","_lastUsed","_removeRenderable","managedRenderables","destroyed","rp","RenderableGCSystem","_TextureGCSystem","count","checkCount","_checkCount","deprecation","maxIdle","gc","checkCountMax","floor","_value","active","textureGCActive","textureGCMaxIdle","textureGCCheckCountMax","textureGCAMaxIdle","TextureGCSystem","_ViewSystem","autoDensity","v8_0_0","screen","createCanvas","getCanvasTexture","transparent","desiredScreenWidth","desiredScreenHeight","removeView","parentNode","SharedSystems","RendererInitHook","SharedRenderPipes","textureBit","textureBitGl","ensureAttributes","extractedData","attributes","attribute","attributeData","_attribute$format","_attribute$offset","_attribute$instance","instance","tempStride","tempStart","buffer","getAttributeInfoFromFormat","stride","_attribute$stride","_attribute$start","ensureStartAndStride","canvasCache","Map","CanvasSource","onDestroy","delete","GlobalResourceRegistry","register","loopMatrix","col","row","uboSyncFunctionsSTD40","f32","i32","uboSyncFunctionsWGSL","GpuStencilModesToPixi","NONE","stencilWriteMask","stencilReadMask","stencilFront","compare","passOp","stencilBack","RenderTargetSystem","rootViewPort","viewport","onRenderTargetChange","SystemRunner","defaultClearColor","_renderSurfaceToRenderTargetHash","_gpuRenderTargetHash","_renderTargetStack","renderableGC","renderStart","_this$adaptor$prerend","_this$adaptor","rootRenderTarget","renderingToScreen","HTMLCanvasElement","contains","isRenderingToScreen","_this$adaptor$postren","_this$adaptor2","renderSurface","getRenderTarget","gpuRenderTarget","getGpuRenderTarget","resizeGpuRenderTarget","pm","flipY","sign","d","calculateProjection","startRenderPass","emit","ALL","contextChange","currentRenderTargetData","_this$_renderSurfaceT","isTexture","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","min","test","destroyGpuRenderTarget","initGpuRenderTarget","resetState","createUboSyncFunction","uboElements","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","data","parsed","uniformParsers","ubo","template","fragmentSrc","Function","uniform","red","UboSystem","_syncFunctionHash","_systemCheck","unsafeEvalSupported","ensureUniformGroup","uniformData","getUniformGroupData","Buffer","layout","usage","BufferUsage","UNIFORM","COPY_DST","_signature","_initUniformGroup","uniformGroupSignature","elements","keys","uniformStructures","createUboElements","syncFunction","_generateUboSync","generateUboSync","syncUniformGroup","uniformGroupData","dataInt32","updateUniformGroup","_dirtyId","synced","abgr","out","BufferResource","EventEmitter","_resourceType","_touched","_resourceId","_bufferResource","onBufferChange","destroyBuffer","removeAllListeners"],"ignoreList":[],"sourceRoot":""}